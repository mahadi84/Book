
প্রোগ্রামিং

"জটিল জিনিসগুলি সহজ যখন আপনি তাদের ভেঙে ফেলেন"

যদি ডিবাগিং সফ্টওয়্যার বাগগুলি সরানোর প্রক্রিয়া হয়, তবে প্রোগ্রামিং অবশ্যই সেগুলি স্থাপন করার প্রক্রিয়া।
—এডসগার ডাইকস্ট্রা, প্রখ্যাত কম্পিউটার বিজ্ঞানী

***
এই অধ্যায় সম্পর্কে অতিরিক্ত ছবি, ভিডিও এবং ভাষ্য জানার জন্য, [http://first20hours.com/programming](http://first20hours.com/programming) দেখুন।

২০০৭ সাল থেকে আমি ওয়েবে জীবিকা নির্বাহ করছি,
যখন আমি প্রক্টর অ্যান্ড গ্যাম্বলে মার্কেটিং ম্যানেজার হিসাবে আমার পূর্ণকালীন চাকরি ছেড়ে দিয়েছিলাম নিজের প্রকাশনা ও পরামর্শ সংস্থা শুরু করার জন্য।

আমার প্রধান ওয়েবসাইট, PersonalMBA.com, আমার জীবিকা: 
আমি কার্যকরভাবে একজন ব্যবসায়িক অধ্যাপক, তবে আমি কোনও বিশ্ববিদ্যালয়ে কাজ করি না। 
প্রতি বছর, আমি আমার পাঠকদের জন্য উপলব্ধ সেরা ব্যবসায়িক বইগুলির তালিকা আপডেট করি যারা নিজেরাই ব্যবসার মৌলিক বিষয়গুলি শিখতে চান। 
২০০৫ সালে প্রথম সংস্করণ প্রকাশের পর থেকে Personal MBA-এর প্রস্তাবিত পঠন তালিকা একটি বহুবর্ষজীবী পাঠক প্রিয়,
এবং তালিকার আপডেটগুলি বিশ্বজুড়ে দর্শকদের ঢেউয়ের সাথে মিলিত হয়।

২০০৫ সাল থেকে, PersonalMBA.com ২ মিলিয়নেরও বেশি পাঠক দ্বারা পরিদর্শন করা হয়েছে।

আমার প্রথম বই, The Personal MBA: Master the Art of Business (২০১০), PersonalMBA.com-এর একটি স্বাভাবিক সম্প্রসারণ ছিল এবং এটি একটি আন্তর্জাতিক বেস্টসেলারে পরিণত হয়েছিল। 
একটি বই লেখার প্রক্রিয়ার একটি অংশ হল কীভাবে কথা ছড়িয়ে দেওয়া যায় তা বের করা, তাই বছরের পর বছর ধরে আমি নতুন পাঠক আকৃষ্ট করার জন্য কঠোর পরিশ্রম করেছি।

ফলস্বরূপ, The Personal MBA নিউ ইয়র্ক টাইমস, ওয়াল স্ট্রিট জার্নাল, ফরচুন, ফোর্বস এবং ফাস্টকোম্পানিতে এবং অনেক জনপ্রিয় ওয়েবসাইট এবং ব্লগে বৈশিষ্ট্যযুক্ত হয়েছে। 
প্রতিবার যখন আমার বই বা ওয়েবসাইট বৈশিষ্ট্যযুক্ত হয়, তখন খুব অল্প সময়ের মধ্যে হাজার হাজার পাঠক PersonalMBA.com পরিদর্শন করেন।



**অগ্রগতির মূল্য**

আপনার ওয়েবসাইটে হাজার হাজার একযোগে দর্শক থাকা একটি দারুণ ব্যাপার, যদি সেই দর্শক আসলে সাইটে পৌঁছাতে পারে। 
সেটাই ছিল আমার সমস্যা: 
যখনই আমার ওয়েবসাইট উল্লেখযোগ্য পরিমাণে ট্র্যাফিক পেত, তখনই তা বিরাট ধুমধামে বন্ধ হয়ে যেত, দর্শকদের কেবল একটি রহস্যময় ত্রুটি বার্তা দিয়ে যেত।

এখানে একটি সাধারণ উদাহরণ: 
Lifehacker.com, একটি জনপ্রিয় উত্পাদনশীলতা ব্লগ, গত সাত বছরে তিনবার The Personal MBA কে বৈশিষ্ট্যযুক্ত করেছে। 
প্রতিবার, হাজার হাজার লোক একই সময়ে PersonalMBA.com পরিদর্শন করার চেষ্টা করত, আমার ওয়েব সার্ভারকে (যে কম্পিউটারটি কোনও দর্শক অনুরোধ করলে একটি ওয়েব পৃষ্ঠা সরবরাহ করে) অভিভূত করে। 
অনুরোধ করা তথ্য সরবরাহ করার পরিবর্তে, আমার সার্ভার "ডাটাবেস সংযোগ স্থাপনে ত্রুটি" বা "Error 503" বার্তা ফেরত দিত, সার্ভারের করুণার জন্য অনুরোধের ডিজিটাল সমতুল্য।

প্রতিবার যখন আমার সার্ভার ভারী লোডের নীচে ক্র্যাশ করত, তখন আমার আত্মার একটি ছোট অংশ তার সাথে মারা যেত। 
আমার ওয়েবসাইট বিপণনে ব্যয় করা সমস্ত সময় নষ্ট হয়েছিল। 
হাজার হাজার কৌতূহলী পাঠক অবশেষে আমি যা অফার করছিলাম তা শিখতে আগ্রহী ছিল, কিন্তু আমার সার্ভার বন্ধ থাকায়, তারা সবাই হতাশ এবং খালি হাতে চলে যাচ্ছিল। 
আমার বিপণন খুব ভালোভাবে কাজ করছিল এবং আমার সিস্টেমগুলি আকস্মিক চাহিদার সাথে মোকাবিলা করতে পারেনি।


**সমস্যা পরীক্ষা করা**

প্রথমদিকে, আমার পদ্ধতি ছিল আরও প্রক্রিয়াকরণ ক্ষমতা এবং আরও মেমরি যোগ করে সার্ভারকে শক্তিশালী করা। 
এটি সাহায্য করেছিল, তবে কেবল একটি নির্দিষ্ট সীমা পর্যন্ত। 
সেই সীমার বাইরে, আমার সাইট ক্র্যাশ করত এবং পুড়ে যেত, যা প্রায় প্রতিটি বড় বিপণন বিজয়ের সাথে মিলে যেত।

সেই সময়, PersonalMBA.com ওয়ার্ডপ্রেস নামক একটি জনপ্রিয় ওয়েবসাইট ম্যানেজমেন্ট সিস্টেমে চলছিল। 
ওয়ার্ডপ্রেস সহজ ইনস্টলেশন এবং ব্যবহারের জন্য অপ্টিমাইজ করা হয়েছে, ভারী লোডের অধীনে পারফরম্যান্সের জন্য নয়। 
ডিফল্ট ওয়ার্ডপ্রেস কনফিগারেশনের অধীনে, 
প্রতিটি ওয়েব পৃষ্ঠার অনুরোধ সার্ভার কার্যকলাপের একটি ক্যাসকেড শুরু করে, 
প্রতিটি ওয়েব পৃষ্ঠা পাঠককে সরবরাহ করার জন্য শত শত লুকানো অনুরোধ তৈরি করে।

এটি প্রতিটি পৃথক ওয়েব পৃষ্ঠার অনুরোধকে "ব্যয়বহুল" করে তোলে। 
অর্থাৎ, প্রতিটি অনুরোধ সম্পন্ন করার জন্য উল্লেখযোগ্য পরিমাণে মেমরি এবং প্রক্রিয়াকরণ ক্ষমতার প্রয়োজন। 
যদি কোনও একক দর্শক ওয়েবসাইটে পাঁচটি পৃষ্ঠা দেখেন, তবে সেই ব্যবহারকারী পাঁচটি ব্যয়বহুল অনুরোধ তৈরি করে। 
যদি এক হাজার দর্শক একই সময়ে একই পৃষ্ঠাটির অনুরোধ করে, তবে সার্ভার একই সাথে এক হাজার অভিন্ন ব্যয়বহুল প্রক্রিয়া শুরু করার চেষ্টা করবে।


**সিস্টেম ডাউন**

এই পরিস্থিতিতে, দরিদ্র বিপর্যস্ত সার্ভার প্রতিটি অনুরোধ ফেরত দেওয়ার চেষ্টা করবে, 
তবে যেহেতু প্রতিটি অনুরোধ প্রচুর সংস্থান দাবি করে, তাই প্রতিটি অনুরোধ পূরণ হওয়ার আগেই সার্ভারের মেমরি শেষ হয়ে যাবে। 
সেই মুহুর্তে, সার্ভার আত্মসমর্পণের সাদা পতাকা উত্তোলন করে এবং দর্শকদের কপাল খারাপ।

এই সমস্যার মোকাবিলা করার জন্য, আমি পাঁচবার ওয়েব-হোস্টিং কোম্পানি পরিবর্তন করেছি 
এবং ভারী লোডের নীচে অনলাইনে থাকার জন্য ওয়ার্ডপ্রেস সার্ভারগুলি কীভাবে কনফিগার করতে হয় তা শিখতে শত শত ঘন্টা ব্যয় করেছি। 
প্রতিটি নতুন সার্ভার কনফিগারেশন জটিলতা বৃদ্ধি করেছে এবং প্রতিটি নতুন ইনস্টলেশনের জন্য আরও বেশি চলমান রক্ষণাবেক্ষণের প্রয়োজন হয়েছে।

অবশেষে আমি আমার নিজস্ব কাস্টম সার্ভার কনফিগারেশন তৈরি করছিলাম, ইনস্টল, কনফিগার 
এবং জটিল সার্ভার অ্যাপ্লিকেশনগুলিকে সংশোধন করার জন্য দীর্ঘ সিরিজের রহস্যময় সিস্টেম কমান্ড আহ্বান করছিলাম যা আমি খুব কমই বুঝতে পারতাম। 
সেটআপ বা রক্ষণাবেক্ষণে আমি যে প্রতিটি ত্রুটি বা সমস্যা অনুভব করেছি তা ঘন্টাখানেক গবেষণা এবং সমস্যা সমাধানে পরিণত হয়েছিল।

যদি তা যথেষ্ট না হত, 
ওয়ার্ডপ্রেসের জনপ্রিয়তা এবং আপেক্ষিক নিরাপত্তাহীনতা এটিকে হ্যাকার এবং স্প্যামারদের জন্য একটি জনপ্রিয় লক্ষ্যে পরিণত করে। 
প্রতি সপ্তাহে বা তার কাছাকাছি, কোনও অসাধু প্রোগ্রামার কিছু নতুন দুর্বলতা খুঁজে বের করে, তারপর ব্যবহারকারীর অ্যাকাউন্ট দখল করতে বা লক্ষ লক্ষ ওয়ার্ডপ্রেস ব্লগ আর্কাইভ স্প্যামে ভরে দিতে ব্যবহার করে। 
ওয়ার্ডপ্রেস ইনস্টলেশন সুরক্ষিত করা এবং সফ্টওয়্যার আপডেটগুলি ট্র্যাক করা নিজেই একটি পূর্ণকালীন কাজ হতে পারে, বিশেষ করে যদি আপনি একাধিক ওয়েবসাইট বজায় রাখেন। 
(আমি সেই সময় বারোটি ওয়েবসাইট বজায় রাখছিলাম এবং শোচনীয়ভাবে ব্যর্থ হচ্ছিলাম।)

একটি নির্দিষ্ট মুহুর্তে, আমি বুঝতে পেরেছিলাম যে-
আমি আমার সাইটগুলিকে অনলাইনে রাখার জন্য আমার পাঠকদের জন্য গবেষণা এবং লেখার চেয়ে বেশি সময় ব্যয় করছি। এটির কোনও মানে ছিল না। 
কেবল আমি উত্পাদনশীল ক্ষমতা নষ্ট করছিলাম না, আমি আসলে প্রোগ্রামিং শিখছিলাম না। আমি কেবল ওয়ার্ডপ্রেস চালানোর জন্য প্রযোজ্য পরিস্থিতি-নির্দিষ্ট কিছু হ্যাক এবং ওয়ার্কআউন্ড শিখছিলাম। ভালো না।

আমি আমার ওয়েবসাইটগুলি বজায় রাখার অন্য উপায় খুঁজতে সিদ্ধান্ত নিয়েছিলাম এবং একটি প্রতিশ্রুতিবদ্ধ বিকল্প খুঁজে পেতে বেশি সময় লাগেনি।


**একটি সম্ভাব্য সমাধান**

একদিন, আমি টম প্রিস্টন-ওয়ার্নার দ্বারা তৈরি একটি ওয়েবসাইট ম্যানেজমেন্ট প্রোগ্রাম জেকিল সম্পর্কে একটি প্রবন্ধের সন্ধান পেয়েছিলাম, 
যিনি ওপেন সোর্স কোড রিপোজিটরি গিটহাবের প্রতিষ্ঠাতা হিসাবে সর্বাধিক পরিচিত।
জেকিল ব্যয়বহুল অনুরোধের উপর নির্ভর করে না এমন ওয়েবসাইটগুলি চালানো সহজ করে ওয়ার্ডপ্রেসের মতো সিস্টেমগুলিকে প্রতিস্থাপনের জন্য ডিজাইন করা হয়েছে।

কল্পনা করুন আপনার কাছে শত শত ওয়ার্ড প্রসেসিং ডকুমেন্ট রয়েছে যাতে গুরুত্বপূর্ণ তথ্য রয়েছে এবং আপনাকে সেগুলিকে একই রকম দেখাতে হবে—একই ফন্ট, একই শিরোনাম শৈলী ইত্যাদি। 
যদি আপনি এমন একটি প্রোগ্রাম লেখেন যা আপনার চয়ন করা একটি নির্দিষ্ট পৃষ্ঠার নকশা স্বয়ংক্রিয়ভাবে প্রতিটি ফাইলে প্রয়োগ করতে পারে (প্রতিটি ফাইল হাতে আপডেট করার বিপরীতে), তবে এটি আপনার অনেক সময় বাঁচাবে।

জেকিল মূলত ওয়েব পেজের জন্য তাই করে। একটি একক কমান্ড চালান এবং জেকিল আপনার কম্পিউটারের ফাইলগুলি ব্যবহার করে একটি সম্পূর্ণ ওয়েবসাইট তৈরি করে যাতে আপনার ওয়েবসাইটের তথ্য এবং ডিজাইন টেমপ্লেট থাকে। 
আপনি যদি ডিজাইন বা পৃষ্ঠার বিষয়বস্তুতে কোনও পরিবর্তন করেন তবে আপনি কেবল জেকিল আবার চালান এবং পুরো সাইটটি স্বয়ংক্রিয়ভাবে পরিবর্তনগুলির সাথে আপডেট হবে, আপনার ঘন্টার প্রচেষ্টা বাঁচাবে।

জেকিল একটি প্রতিশ্রুতিবদ্ধ সুযোগ উপস্থাপন করেছে। তাত্ত্বিকভাবে, আমি আমার কম্পিউটারে টেক্সট ফাইলগুলির একটি সরল ফোল্ডার দিয়ে ওয়ার্ডপ্রেস প্রতিস্থাপন করতে পারি। 
আমার ওয়েবসাইটটি দ্রুত, অতি স্থিতিশীল হবে এবং আমি প্রতি বছর একশ ঘন্টারও বেশি সার্ভার রক্ষণাবেক্ষণ থেকে নিজেকে বাঁচাতে পারব।

তবে, একটি ক্যাচ ছিল: জেকিল রুবিতে লেখা, একটি প্রোগ্রামিং ভাষা যা আমি জানি না। রুবিতে কোড লিখতে বা রুবি অ্যাপ্লিকেশনগুলি চালাতে আমার কোনও ধারণা নেই যা আসল ব্যবহারকারীদের পরিবেশন করে। 
PersonalMBA.com চালানোর জন্য আমাকে যা করতে হবে তার কিছু সাধারণ ফর্ম্যাটিংয়ের চেয়ে বেশি প্রয়োজন।

জেকিল ব্যবহার করে আমার ওয়েবসাইটগুলি চালানোর জন্য, আমাকে রুবি ওয়েব অ্যাপ্লিকেশনগুলি প্রোগ্রাম এবং স্থাপন করতে শিখতে হবে।

মনে হচ্ছে আমি একটি "ভালোবাসার যোগ্য সমস্যা" খুঁজে পেয়েছি।

**কোডিং শেখা**

আমি বেশ কিছুদিন ধরে প্রোগ্রামিং শিখতে চেয়েছি, কিন্তু অন্যান্য প্রকল্প সবসময় অগ্রাধিকার পেয়েছে। 
যদি আমি কোড করতে শিখতে পারি, তবে আমার প্রকাশনা এবং ব্যবসার সুযোগগুলি উল্লেখযোগ্যভাবে প্রসারিত হবে,
কারণ আমার ব্যবসা গড়ে তোলার জন্য আমি যা কিছু করি তা ওয়েবে চলে।

এটি উল্লেখ করা গুরুত্বপূর্ণ যে আমি আজ পর্যন্ত যা কিছু করেছি তা প্রোগ্রামিং নয়। 
HTML এবং CSS, যে ভাষাগুলি আমি ওয়েব পৃষ্ঠা তৈরি করতে ব্যবহার করি, সেগুলিকে "মার্কআপ" ভাষা বলা হয়। 
HTML এবং CSS কোড কোনওভাবেই স্মার্ট নয়: 
এটি কেবল কম্পিউটারকে ব্যবহারকারীকে একটি নির্দিষ্ট উপায়ে একটি টেক্সট ফাইল দেখাতে বলে (যেমন, "এই টেক্সটটিকে মোটা করুন" বা "এই বিভাগটি ২৪-পয়েন্ট ফন্ট আকারের একটি শিরোনাম")।

আমার পাগল সার্ভার সেটআপের ক্ষেত্রেও একই কথা প্রযোজ্য। 
যদিও আমি সফ্টওয়্যার একত্রিত করছিলাম, আমি আসলে প্রোগ্রামিং করছিলাম না। 
পরিবর্তে, আমি পূর্বলিখিত প্রোগ্রামগুলি ইনস্টল করছিলাম, তারপর কয়েকটি সেটিংস পরিবর্তন করছিলাম। 
প্রোগ্রামাররা আমি যে অ্যাপ্লিকেশনগুলি ব্যবহার করছিলাম সেগুলি লিখেছিলেন, 
তবে সেগুলি ব্যবহার করার জন্য আমার প্রোগ্রামিংয়ের কোনও জ্ঞানের প্রয়োজন ছিল না। সার্ভার কনফিগারেশন এবং প্রশাসন একটি দরকারী দক্ষতা, তবে এটি প্রোগ্রামিং নয়।

**তাহলে "প্রোগ্রামিং" কী?**

আমার প্রথম ধারণা হল প্রোগ্রামিং কম্পিউটারকে জিনিসপত্র করতে বলা, তবে এটি খুব নির্দিষ্ট বা সহায়ক নয়। কী করতে? কী "জিনিস"?

দশ বছর আগে, আমি কলেজে দুটি মৌলিক প্রোগ্রামিং কোর্স নিয়েছিলাম, তাই একটি দরকারী সংজ্ঞা তৈরি করতে না পারা, সত্যি বলতে, কিছুটা বিব্রতকর।
আমার কয়েকটি মৌলিক শব্দ মনে আছে, যেমন ভেরিয়েবল, লুপ, ইনপুট, আউটপুট, ফাংশন, অবজেক্ট ওরিয়েন্টেশন এবং বাবল সর্ট নামক কিছু, তবে আর বেশি কিছু নয়।

কোর্সের অ্যাসাইনমেন্টগুলির জন্য C++ নামক একটি প্রোগ্রামিং ভাষা শেখা প্রয়োজন ছিল এবং 
আমার মনে আছে যখন একটি অনুপস্থিত সেমিকোলন খুঁজে পেতে ঘন্টাখানেক সময় লেগেছিল 
যা আমার প্রোগ্রামটিকে ক্র্যাশ করছিল তখন আমি হতাশ হয়েছিলাম। 
আমার মনে আছে আমার অধ্যাপক বলছিলেন- 
"আপনি বাস্তব অ্যাপ্লিকেশনের জন্য কখনই বাবল সর্ট ব্যবহার করবেন না, তবে আমরা এটি শিখব।"

আমি কোর্সের জন্য কয়েকটি মৌলিক প্রোগ্রাম লিখেছিলাম কারণ আমাকে লিখতে হয়েছিল: 
লক্ষ্য ছিল ভাল গ্রেড নিয়ে ক্লাস পাস করা এবং আমি তা করেছিলাম।
দুর্ভাগ্যবশত, আমরা যে প্রোগ্রামগুলি লিখছিলাম তার ক্লাসরুমের বাইরে কোনও বাস্তব ব্যবহার ছিল না এবং আমি দীর্ঘকাল ধরে এই ধারণাগুলি ব্যবহার করিনি। 
যদিও আমার কয়েকটি শব্দ মনে আছে, মূল ধারণাগুলি বোঝার ক্ষেত্রে আমাকে আবার শুরু করতে হবে।

যেহেতু আমি নির্দিষ্টভাবে সংজ্ঞায়িত করতে পারছি না 
যে আমি যখন "প্রোগ্রামিং শিখতে" চাই তখন আমি কী করার চেষ্টা করছি, 
তাই আমি একটি দরকারী লক্ষ্য কর্মক্ষমতার স্তর সংজ্ঞায়িত করতে সমস্যায় পড়ব। 
"একটি কম্পিউটার প্রোগ্রাম তৈরি করুন" কিছুটা বেশি নির্দিষ্ট, তবে এখনও খুব দরকারী নয়।

প্রোগ্রামিং সম্পর্কে আমি বর্তমানে যা জানি তা উন্মোচন করার সময়:

* আমি জানি প্রোগ্রামাররা প্রোগ্রাম "লিখে", যা ইঙ্গিত করে যে এটি একটি সৃজনশীল অনুশীলন যা বিভিন্ন উপায়ে করা যেতে পারে।
* প্রোগ্রামগুলিকে প্রায়শই "অ্যাপ্লিকেশন" বলা হয় এবং শব্দগুলি পরস্পর পরিবর্তনযোগ্যভাবে ব্যবহৃত হয়।
* যখন কম্পিউটার প্রোগ্রাম "রান" বা "এক্সিকিউট" করা হয়, তখন তারা যা করার জন্য লেখা হয়েছিল তা করে, তা যাই হোক না কেন।
* "ইনপুট" এবং "আউটপুট" মনে রাখা সহজ, কারণ সেগুলি সাধারণ ব্যবহারে রয়েছে। ইনপুট হল তথ্য বা ডেটা যা প্রোগ্রাম ব্যবহার করে এবং আউটপুট হল প্রোগ্রামটি রান করা শেষ হলে আপনি যা পান।
* একটি "ভেরিয়েবল" মূলত এমন কিছুর জন্য একটি স্থানধারক যা পরিবর্তিত হয়। আপনি যত খুশি ভেরিয়েবল তৈরি করতে পারেন এবং সেই ভেরিয়েবলগুলিকে আপনি যা চান তার জন্য দাঁড় করাতে পারেন।
* "প্রোগ্রাম" নিজেই মূলত বিস্তারিত নির্দেশাবলী এবং নিয়মের একটি সেট যা কম্পিউটারকে ইনপুট (বা তার সাথে) কী করতে হবে তা সঠিকভাবে বলে। প্রোগ্রামটি রান করা শেষ হলে, এটি আপনাকে আউটপুট দেয়।
* প্রোগ্রাম "ক্র্যাশ" করে বা একটি ত্রুটি বার্তা প্রদর্শন করে যখন কিছু ভুল হয় বা কম্পিউটার বুঝতে পারে না যে এর পরে কী করতে হবে।

এখন আমরা কোথাও যাচ্ছি। এটি একটি খুব মৌলিক পুনর্গঠন: "প্রোগ্রামিং"-এর পরিবর্তে, এখন আমাদের সাথে কাজ করার জন্য তিনটি উপধারণা রয়েছে:

* **ইনপুট**—একটি প্রক্রিয়া কার্যকর করার জন্য আপনি যে তথ্য ব্যবহার করেন।
* **প্রক্রিয়া**—ইনপুট দেওয়া হলে প্রোগ্রামটি যে পদক্ষেপগুলি নেয় তার একটি সিরিজ।
* **আউটপুট**—প্রোগ্রামের চূড়ান্ত ফলাফল।

এই বিশ্লেষণ অনেক বেশি দরকারী। 
"একটি কম্পিউটার প্রোগ্রাম লেখা" মানে আপনি কী তথ্য দিয়ে শুরু করছেন তা সংজ্ঞায়িত করা,
এমন একটি পদক্ষেপের সিরিজ সংজ্ঞায়িত করা যা সঠিকভাবে বর্ণনা করে যে কম্পিউটার সেই ইনপুটটির সাথে কী করবে 
এবং প্রোগ্রামটি রান করা শেষ হলে কম্পিউটারটি যে আউটপুট ফেরত দেবে তা সংজ্ঞায়িত করা।

একটি ফ্লোচার্টের কথা ভাবুন, 
যা প্রোগ্রামগুলি কীভাবে কাজ করে তার জন্য একটি দরকারী মানসিক ধারণা বলে মনে হয়। 
আপনি নির্দিষ্ট ইনপুট দিয়ে প্রক্রিয়াটি শুরু করেন। পথে, নির্দিষ্ট শর্ত সত্য বা মিথ্যা হলে আপনি নির্দিষ্ট পদক্ষেপ নেন।
ফ্লোচার্টের শেষে পৌঁছালে প্রক্রিয়াটি শেষ হয় এবং 
আপনি আউটপুট পান: ফ্লোচার্টটি বর্ণনা করে এমন সম্পূর্ণ প্রক্রিয়ার চূড়ান্ত ফলাফল।

একটি কম্পিউটার প্রোগ্রাম তৈরি করা ফ্লোচার্ট তৈরি করার সময় আপনি যে ধরণের চিন্তা করেন তার থেকে আলাদা উপায়ে একই ধরণের চিন্তা করা বলে মনে হয়। 
আপনি একই ধরণের প্রশ্ন জিজ্ঞাসা করেন:

* আমি কী দিয়ে শুরু করছি?
* প্রক্রিয়ার শুরুতে কী ঘটে?
* এর পরে কী ঘটে? তার পরে?
* প্রক্রিয়া কখন শেষ হয়?
* প্রক্রিয়া শেষ হলে আমার কী থাকে?

ফ্লোচার্ট এই প্রশ্নগুলির উত্তর একটি ভিজ্যুয়াল ফরম্যাটে বর্ণনা করে এবং প্রোগ্রামগুলি টেক্সট ব্যবহার করে সেগুলি বর্ণনা করে, তবে চিন্তাভাবনার প্রক্রিয়া একই।

ফ্লোচার্ট উপমাটিও দরকারী কারণ এটি সম্ভবত গুরুত্বপূর্ণ অন্যান্য ধারণা সম্পর্কে কয়েকটি সূত্র সরবরাহ করে।

**শর্তাধীন বিবৃতি** হল এমন বিবৃতি যেমন:

* "যদি X সত্য/মিথ্যা হয় তবে Y করুন"
* "যদি X Y হয়/না হয় তবে Z করুন"
* "যখন X সত্য/মিথ্যা হয় তখন Y করুন"
* "যখন X Y হয় তখন Z করুন"
* "যতক্ষণ X সত্য/মিথ্যা হয় ততক্ষণ Y করুন"
* "যতক্ষণ X Y হয় ততক্ষণ Z করুন"

এই ক্ষেত্রে X, Y এবং Z হল ভেরিয়েবল, যা যেকোনো কিছুর জন্য দাঁড়াতে পারে।
ভেরিয়েবলগুলি মৌলিক বীজগণিতের মতো সংখ্যাগুলির জন্য দাঁড়াতে পারে, 
অথবা সেগুলি শব্দের জন্য দাঁড়াতে পারে। কখনও কখনও ভেরিয়েবলগুলি একক অক্ষর বা প্রতীক হয় এবং কখনও কখনও সেগুলি শব্দ হয়।
যাই হোক না কেন, তারা আমরা যা নিয়ে কাজ করছি তা উপস্থাপন করে।

শর্তাধীন বিবৃতি (IF, THEN, WHEN এবং WHILE অংশ) একটি ফ্লোচার্টের প্রশ্নের তীরগুলির মতো। 
গাড়ি চালানোর কথা ভাবুন: **যদি** ট্র্যাফিক লাইট লাল হয়, **তবে** থামুন। 
**যখন** ট্র্যাফিক লাইট সবুজ হয়, **তখন** যান। **যখন** ট্র্যাফিক লাইট হলুদ হয়, গতি কমান এবং থামার জন্য প্রস্তুত হন।

এই শর্তাধীন বিবৃতিগুলি আরও একটু গভীরভাবে বোঝা মূল্যবান, কারণ কয়েকটি সাধারণ প্যাটার্ন রয়েছে। 
সত্য/মিথ্যা অনেকবার আসে এবং WHILE দেখে মনে হয় আমরা একটি একক পদক্ষেপ নেওয়ার পরিবর্তে কিছু করতে থাকি।

সমস্ত ক্ষেত্রে, শর্তাধীনে এমন কিছু বিবৃতি থাকে যা নির্ধারণ করে যে পদক্ষেপ নেওয়া হবে কিনা। 
এই বিবৃতিটিকে একটি শর্ত বলা হয় এবং এটি বিভিন্ন রূপ নিতে পারে। 
কখনও কখনও শর্তটি একটি মৌলিক সত্য/মিথ্যা (আলো কি লাল?) তুলনা, কখনও কখনও এটি একটি গাণিতিক তুলনা (X কি 100 এর চেয়ে বড়?), 
এবং কখনও কখনও এতে যুক্তি থাকে (স্টপলাইট কি লাল **নয়**?)।

শর্তের উদ্দেশ্য হল সংশ্লিষ্ট প্রক্রিয়াটি ঘটবে কিনা তা নির্ধারণ করা।
যদি শর্তটি সত্য বা বৈধ হয়, প্রোগ্রামটি নির্দেশাবলী প্রক্রিয়া করে। 
যদি তা না হয়, সংশ্লিষ্ট নির্দেশাবলী বাদ দেওয়া হয় এবং প্রোগ্রামটি পরবর্তী নির্দেশনায় চলে যায়।

সত্য/মিথ্যা ভেরিয়েবলগুলিকে বুলিয়ান ভেরিয়েবল বলা হয়, 
যা এমন কিছুর জন্য একটি অভিনব শব্দ যার কেবল দুটি বিকল্প থাকে। 
হ্যাঁ/না এবং চালু/বন্ধও বুলিয়ান ভেরিয়েবল। বুলিয়ান ভেরিয়েবলগুলি কম্পিউটার প্রোগ্রামগুলিতে বেশ গুরুত্বপূর্ণ, কারণ সেগুলি সরল প্রক্রিয়াগুলির (যেমন একটি ফ্লোচার্টের সত্য/মিথ্যা) 
এবং কম্পিউটারের মূল অংশে থাকা ক্ষুদ্র ইলেকট্রনিক সুইচের চালু/বন্ধ ফ্লিপিং উভয়ের মৌলিক একক।

এই ক্ষেত্রে WHILE হল একটি বিশেষ ধরণের শর্তাধীন বিবৃতি যাকে লুপ বলা হয়। 
লুপগুলি শর্ত পূরণ না হওয়া পর্যন্ত প্রশ্নে থাকা প্রক্রিয়াটিকে পুনরাবৃত্তি করে। গাড়ি চালানোর উপমায় ফিরে যাওয়া: **যতক্ষণ** ট্র্যাফিক লাইট লাল থাকে, ততক্ষণ নড়াচড়া করবেন না।

বেশ সহজ, তাই না? যদি আমরা একটি কম্পিউটার প্রোগ্রাম লেখাকে একটি ফ্লোচার্ট আঁকার মতো ভাবি, তবে মৌলিক প্রক্রিয়াটি কল্পনা করা সহজ।

আরেকটি শেষ জটিলতা: কম্পিউটার যদি আটকে যায়, কী করতে হবে তা না জানে, 
অথবা কম্পিউটার যে নির্দেশাবলী চেষ্টা করে তা যদি কোনও পর্যায়ে কাজ না করে বা অর্থবোধক না হয়? কী ঘটে?

প্রোগ্রাম "ক্র্যাশ" করে—প্রোগ্রামটি সম্পূর্ণভাবে বন্ধ হয়ে যায় এবং প্রায়শই কাঙ্ক্ষিত ফলাফলের পরিবর্তে একটি ত্রুটি বার্তা আউটপুট করে। 
আমরা সবাই ওয়েব ব্রাউজ করার সময় ভয়ানক উইন্ডোজ "নীল মৃত্যুর পর্দা" বা "Error 404: Web Page Not Found" ত্রুটি অনুভব করেছি। অপ্রত্যাশিত কিছু ঘটে, কম্পিউটার ভয় পেয়ে যায় এবং প্রোগ্রামটি ক্র্যাশ করে।

একজন কম্পিউটার প্রোগ্রামার হিসাবে,
আপনার কাজ হল ক্র্যাশ এবং ত্রুটিগুলি ঘটতে বাধা দেওয়া। 
এটি করার সর্বোত্তম উপায় হল প্রোগ্রামটির পরিকল্পনা অনুযায়ী প্রক্রিয়াটি সম্পন্ন করার জন্য প্রয়োজনীয় তথ্য সর্বদা রয়েছে তা নিশ্চিত করা, তবে এটি সর্বদা সম্ভব নয়। 
অনিশ্চয়তা অনিবার্য ক্ষেত্রে, এটি দরকারী ত্রুটিপূর্ণ পরিস্থিতিতে প্রোগ্রামটিকে আরও সুশৃঙ্খলভাবে ব্যর্থ হতে শেখানো।

ত্রুটি হ্যান্ডলিং নামক একটি কৌশল ব্যবহার করে, 
প্রোগ্রামাররা অপ্রত্যাশিত সমস্যাগুলি কীভাবে পরিচালনা করতে হবে তা নির্ধারণ করতে পারেন। 
উদাহরণস্বরূপ, যদি প্রোগ্রামটি কোনও ফাইল খোলার চেষ্টা করে তবে ফাইলটি খুঁজে না পায়,
প্রোগ্রামটি ক্র্যাশ হওয়ার পরিবর্তে ব্যবহারকারীকে একটি দরকারী বার্তা প্রদর্শন করতে পারে ("দুঃখিত, সেই ফাইলটি খুঁজে পাওয়া যায়নি। আপনি কি ফাইলের নামটি সঠিকভাবে টাইপ করেছেন?")।

ত্রুটি হ্যান্ডলিং প্রোগ্রামগুলিকে আরও স্থিতিশীল এবং ব্যবহারকারী-বান্ধব করে তোলে, কারণ অপ্রত্যাশিত সমস্যাগুলি ঘটলেও তারা সম্পূর্ণরূপে ভেঙে পড়ে না।

**লক্ষ্য কর্মক্ষমতার স্তর**

এই মৌলিক ধারণাগুলির সাথে, আমি এখন প্রোগ্রামিং শেখা শুরু করার জন্য একটি দরকারী লক্ষ্য কর্মক্ষমতার স্তর সংজ্ঞায়িত করতে পারি:

১. একটি প্রোগ্রামিং ভাষা শিখুন যা আমাকে আমার কম্পিউটারকে মৌলিক জিনিসগুলি করতে বলার অনুমতি দেয় (যেমন, কিছু ডেটা প্রক্রিয়া করা এবং ফলাফল প্রদর্শন করা)।
২. সেই ভাষা ব্যবহার করে একটি মৌলিক প্রোগ্রাম তৈরি করুন যা একটি বাস্তব-বিশ্বের সমস্যা সমাধান করে (যেমন, একটি ওয়েব পৃষ্ঠা তৈরি করা)।
৩. প্রোগ্রামিংয়ের মৌলিক ধারণাগুলি বুঝুন (ইনপুট, প্রক্রিয়া, আউটপুট, ভেরিয়েবল, শর্তাধীন বিবৃতি এবং লুপ)।
৪. ত্রুটি হ্যান্ডলিংয়ের মৌলিক ধারণাগুলি বুঝুন যাতে আমি আমার প্রোগ্রামগুলিকে আরও স্থিতিশীল করতে পারি।

এই লক্ষ্যগুলি অর্জন করতে আমার কতক্ষণ সময় লাগবে তা আমি নিশ্চিত নই, তবে সেগুলি যথেষ্ট নির্দিষ্ট যে আমি আমার অগ্রগতি ট্র্যাক করতে পারি।

**একটি প্রোগ্রামিং ভাষা নির্বাচন**

আমার প্রথম কাজ হল শেখা শুরু করার জন্য একটি প্রোগ্রামিং ভাষা নির্বাচন করা। 
বাজারে কয়েক ডজন প্রোগ্রামিং ভাষা রয়েছে, প্রতিটি নিজস্ব শক্তি এবং দুর্বলতা সহ।

কিছু ভাষা নির্দিষ্ট ধরণের কাজের জন্য ডিজাইন করা হয়েছে (যেমন, রুবি ওয়েব ডেভেলপমেন্টের জন্য ভাল, C++ সিস্টেম প্রোগ্রামিংয়ের জন্য ভাল)। 
যেহেতু আমার প্রাথমিক লক্ষ্য হল জেকিল ব্যবহার করে আমার ওয়েবসাইটগুলি পরিচালনা করা, তাই রুবি শেখা একটি সুস্পষ্ট পছন্দ বলে মনে হয়।

রুবি একটি জনপ্রিয়, উচ্চ-স্তরের প্রোগ্রামিং ভাষা যা তার সরলতা এবং পঠনযোগ্যতার জন্য পরিচিত। 
এটি ওয়েব ডেভেলপমেন্টের জন্য একটি শক্তিশালী ভাষা এবং জেকিল রুবিতে লেখা হয়েছে, তাই রুবি শেখা আমাকে জেকিল বুঝতে এবং কাস্টমাইজ করতে সাহায্য করবে।

রুবি শেখা শুরু করার জন্য প্রচুর বিনামূল্যে রিসোর্সও রয়েছে, যা একটি বড় প্লাস।

**রুবি শেখা**

আমি রুবি শেখা শুরু করার জন্য বেশ কয়েকটি রিসোর্স সংগ্রহ করেছি:

* **Learn Ruby the Hard Way** ([http://learnrubythehardway.org/](http://learnrubythehardway.org/)) - একটি বিনামূল্যে অনলাইন বই যা রুবি প্রোগ্রামিংয়ের মৌলিক বিষয়গুলি শেখানোর জন্য ডিজাইন করা হয়েছে।
* **Codecademy** ([http://www.codecademy.com/](http://www.codecademy.com/)) - একটি ইন্টারেক্টিভ ওয়েবসাইট যা রুবি এবং অন্যান্য প্রোগ্রামিং ভাষা শেখানোর জন্য ডিজাইন করা হয়েছে।
* **The Ruby Programming Language** ([http://www.amazon.com/Ruby-Programming-Language-David-Flanagan/dp/0596516177/](https://www.google.com/search?q=http://www.amazon.com/Ruby-Programming-Language-David-Flanagan/dp/0596516177/)) - রুবি প্রোগ্রামিংয়ের একটি ব্যাপক রেফারেন্স বই।

আমি Learn Ruby the Hard Way দিয়ে শুরু করব, কারণ এটি শিক্ষানবিশদের জন্য ডিজাইন করা হয়েছে এবং এটি বিনামূল্যে। বইটিতে অনুশীলনের একটি সিরিজ রয়েছে যা আমাকে রুবি প্রোগ্রামিংয়ের মৌলিক ধারণাগুলির সাথে পরিচিত করবে।

**প্রথম প্রোগ্রাম**

Learn Ruby the Hard Way-এর প্রথম অনুশীলনটি আমাকে টার্মিনাল উইন্ডোতে "Hello, World!" প্রিন্ট করার জন্য একটি মৌলিক রুবি প্রোগ্রাম লিখতে বলে। প্রোগ্রামটি দেখতে এইরকম:

```ruby
puts "Hello, World!"
```

এই প্রোগ্রামটি run করার জন্য, আমাকে প্রথমে আমার কম্পিউটারে রুবি ইনস্টল করতে হবে। রুবি ওয়েবসাইট ([http://www.ruby-lang.org/en/downloads/](http://www.ruby-lang.org/en/downloads/)) থেকে আমি ম্যাক ওএস এক্সের জন্য ইনস্টলার ডাউনলোড করেছি এবং নির্দেশাবলী অনুসরণ করে রুবি ইনস্টল করেছি।

রুবি ইনস্টল করার পরে, আমি একটি টেক্সট এডিটর (আমি Sublime Text ব্যবহার করছি) খুলেছি এবং উপরের কোডটি টাইপ করেছি। আমি ফাইলটিকে `hello.rb` নামে সেভ করেছি।

তারপর, আমি টার্মিনাল উইন্ডো খুলেছি, সেই ডিরেক্টরিতে নেভিগেট করেছি যেখানে আমি ফাইলটি সেভ করেছি এবং `ruby hello.rb` কমান্ডটি রান করেছি। টার্মিনাল উইন্ডোতে নিম্নলিখিত আউটপুট প্রদর্শিত হয়েছে:

```
Hello, World!
```

এটি আমার প্রথম রুবি প্রোগ্রাম! এটি খুব বেশি কিছু নয়, তবে এটি একটি শুরু। আমি আমার কম্পিউটারকে কিছু করতে বলেছি এবং এটি তা করেছে।

**পরবর্তী পদক্ষেপ**

Learn Ruby the Hard Way-এর পরবর্তী অনুশীলনগুলি রুবি প্রোগ্রামিংয়ের আরও মৌলিক ধারণাগুলি শেখানো অব্যাহত রেখেছে, যেমন ভেরিয়েবল, ডেটা টাইপ, অপারেটর, শর্তাধীন বিবৃতি এবং লুপ। প্রতিটি অনুশীলনের পরে, আমি কোডটি লিখেছি এবং রান করেছি এবং বইটিতে দেওয়া অনুশীলনগুলি সম্পন্ন করেছি।

আমি Codecademy-এর রুবি কোর্সও সম্পন্ন করেছি, যা মৌলিক ধারণাগুলিকে শক্তিশালী করতে এবং আরও ইন্টারেক্টিভ উপায়ে অনুশীলন করার সুযোগ দিয়েছে।

এই রিসোর্সগুলি ব্যবহার করে, আমি রুবি প্রোগ্রামিংয়ের মৌলিক বিষয়গুলির একটি দৃঢ় ভিত্তি তৈরি করতে সক্ষম হয়েছি। আমি এখন মৌলিক প্রোগ্রাম লিখতে এবং রান করতে, ভেরিয়েবল এবং ডেটা টাইপ ব্যবহার করতে, শর্তাধীন বিবৃতি এবং লুপ ব্যবহার করে প্রোগ্রামগুলির প্রবাহ নিয়ন্ত্রণ করতে এবং ত্রুটি হ্যান্ডলিংয়ের মৌলিক ধারণাগুলি বুঝতে পারি।

**একটি বাস্তব-বিশ্বের সমস্যা সমাধান**

রুবি প্রোগ্রামিংয়ের মৌলিক বিষয়গুলি শেখার পরে, আমার পরবর্তী লক্ষ্য হল সেই জ্ঞান ব্যবহার করে একটি বাস্তব-বিশ্বের সমস্যা সমাধান করে এমন একটি প্রোগ্রাম তৈরি করা। যেহেতু আমার প্রাথমিক লক্ষ্য হল জেকিল ব্যবহার করে আমার ওয়েবসাইটগুলি পরিচালনা করা, তাই আমি একটি মৌলিক ওয়েব পৃষ্ঠা তৈরি করার জন্য একটি রুবি প্রোগ্রাম লেখার সিদ্ধান্ত নিয়েছি।

আমি একটি সরল HTML ফাইল তৈরি করে শুরু করেছি যাতে আমার ওয়েবসাইটের বিষয়বস্তু থাকবে। তারপর, আমি একটি রুবি প্রোগ্রাম লিখেছি যা সেই HTML ফাইলটি পড়ে এবং একটি নতুন HTML ফাইল তৈরি করে যাতে একটি মৌলিক ডিজাইন টেমপ্লেট প্রয়োগ করা হয়।

প্রোগ্রামটি দেখতে এইরকম:

```ruby
# HTML ফাইল থেকে বিষয়বস্তু পড়ুন
content = File.read("content.html")

# ডিজাইন টেমপ্লেট সংজ্ঞায়িত করুন
template = %{
<!DOCTYPE html>
<html>
<head>
  <title>আমার ওয়েবসাইট</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="container">
    <%= content %>
  </div>
</body>
</html>
}

# বিষয়বস্তু টেমপ্লেটে প্রতিস্থাপন করুন
output = template.gsub("<%= content %>", content)

# আউটপুট ফাইল লিখুন
File.open("index.html", "w") { |f| f.write(output) }

puts "index.html তৈরি করা হয়েছে"
```

এই প্রোগ্রামটি run করার জন্য, আমাকে `content.html` নামক একটি ফাইল তৈরি করতে হবে যাতে আমার ওয়েবসাইটের বিষয়বস্তু থাকবে এবং `style.css` নামক একটি ফাইল তৈরি করতে হবে যাতে আমার ওয়েবসাইটের মৌলিক ডিজাইন থাকবে। তারপর, আমি টার্মিনাল উইন্ডোতে প্রোগ্রামটি রান করতে পারি:

```
ruby generate_website.rb
```

এটি `index.html` নামক একটি নতুন ফাইল তৈরি করবে যাতে `content.html`-এর বিষয়বস্তু এবং `style.css`-এর ডিজাইন প্রয়োগ করা হবে।

এটি একটি খুব মৌলিক প্রোগ্রাম, তবে এটি দেখায় যে আমি রুবি ব্যবহার করে একটি বাস্তব-বিশ্বের সমস্যা সমাধান করতে পারি। আমি এখন এই প্রোগ্রামটিকে আরও জটিল বৈশিষ্ট্য যুক্ত করতে পারি, যেমন একাধিক পৃষ্ঠা তৈরি করার ক্ষমতা, মেনু এবং নেভিগেশন যোগ করার ক্ষমতা এবং বিভিন্ন ধরণের বিষয়বস্তু পরিচালনা করার ক্ষমতা।

**জেকিল বোঝা**

রুবি প্রোগ্রামিংয়ের মৌলিক বিষয়গুলি শেখা এবং একটি মৌলিক ওয়েব পৃষ্ঠা তৈরি করার জন্য একটি রুবি প্রোগ্রাম লেখার পরে, আমি জেকিল কীভাবে কাজ করে তা আরও ভালভাবে বুঝতে শুরু করেছি। জেকিল মূলত টেক্সট ফাইল এবং টেমপ্লেট ব্যবহার করে একটি সম্পূর্ণ ওয়েবসাইট তৈরি করার জন্য রুবি প্রোগ্রামগুলির একটি সংগ্রহ।

জেকিল ব্যবহার করার জন্য, আমাকে প্রথমে আমার কম্পিউটারে জেকিল ইনস্টল করতে হবে। জেকিল ওয়েবসাইট ([http://jekyllrb.com/](http://jekyllrb.com/)) থেকে আমি ইনস্টলার ডাউনলোড করেছি এবং নির্দেশাবলী অনুসরণ করে জেকিল ইনস্টল করেছি।

জেকিল ইনস্টল করার পরে, আমি আমার ওয়েবসাইটের ফাইলগুলির একটি ফোল্ডার তৈরি করতে পারি। এই ফোল্ডারে আমার ওয়েবসাইটের বিষয়বস্তু (টেক্সট ফাইল, মার্কডাউন ফাইল, HTML ফাইল), ডিজাইন টেমপ্লেট (লিকুইড টেমপ্লেট ফাইল), অ্যাসেট (CSS ফাইল, জাভাস্ক্রিপ্ট ফাইল, ছবি) এবং কনফিগারেশন ফাইল (YAML ফাইল) থাকবে।

তারপর, আমি টার্মিনাল উইন্ডোতে সেই ফোল্ডারে নেভিগেট করতে পারি এবং `jekyll build` কমান্ডটি রান করতে পারি। জেকিল আমার ওয়েবসাইটের ফাইলগুলি প্রক্রিয়া করবে এবং `_site` নামক একটি নতুন ফোল্ডারে একটি সম্পূর্ণ স্ট্যাটিক ওয়েবসাইট তৈরি করবে। আমি তারপর সেই ওয়েবসাইটটিকে কোনও ওয়েব সার্ভারে আপলোড করতে পারি এবং এটি ইন্টারনেটে প্রকাশ করতে পারি।

জেকিল ব্যবহার করে, আমি এখন ওয়ার্ডপ্রেসের জটিলতা এবং রক্ষণাবেক্ষণের প্রয়োজনীয়তা ছাড়াই একটি দ্রুত, স্থিতিশীল এবং সুরক্ষিত ওয়েবসাইট তৈরি এবং পরিচালনা করতে পারি।

**উপসংহার**

এই অধ্যায়ে, আমি প্রোগ্রামিংয়ের মৌলিক ধারণাগুলি শিখেছি, একটি প্রোগ্রামিং ভাষা (রুবি) শিখেছি, একটি বাস্তব-বিশ্বের সমস্যা সমাধান করে এমন একটি মৌলিক প্রোগ্রাম তৈরি করেছি এবং জেকিল কীভাবে কাজ করে তা বুঝেছি। এই জ্ঞান ব্যবহার করে, আমি এখন আমার ওয়েবসাইটগুলি পরিচালনা করতে এবং ভবিষ্যতে আরও জটিল ওয়েব অ্যাপ্লিকেশন তৈরি করতে পারি।

এই প্রক্রিয়াটি দেখিয়েছে যে জটিল জিনিসগুলি ভেঙে ফেললে সহজ হয়ে যায়। প্রোগ্রামিং প্রথমে একটি ভীতিজনক বিষয় মনে হতে পারে, তবে মৌলিক ধারণাগুলি বোঝার মাধ্যমে এবং ছোট, পরিচালনাযোগ্য পদক্ষেপ নেওয়ার মাধ্যমে, যে কেউ প্রোগ্রামিং শিখতে পারে এবং এটি ব্যবহার করে বাস্তব-বিশ্বের সমস্যা সমাধান করতে পারে।

অবশ্যই, বাকি অংশটুকু এখানে দেওয়া হলো:

একটি প্রক্রিয়া সম্পন্ন করার চেষ্টা করার সময় প্রোগ্রাম ব্যর্থ হলে পুনরুদ্ধারের একটি উপায় থাকা।

এই ত্রুটি-পুনরুদ্ধার বিবৃতিগুলিকে ব্যতিক্রম বলা হয় এবং এগুলি খুব কাজে লাগে। আপনি এগুলিকে ত্রুটি-নির্দিষ্ট শর্ত হিসাবে ভাবতে পারেন: যদি প্রোগ্রামটি X উপায়ে ক্র্যাশ হতে চলেছে, তবে ক্র্যাশ হওয়ার পরিবর্তে Y করুন।

ব্যতিক্রমগুলি একটি হাসপাতালের বিল্ডিংয়ে একটি ব্যাকআপ জেনারেটর যুক্ত করার মতো। বেশিরভাগ সময়, জেনারেটরটি কেবল সেখানে বসে থাকে, কিছুই করে না। যদি বিদ্যুৎ চলে যায়, তবে জেনারেটরটি চালু হয় এবং হাসপাতালটি পুরোপুরি অন্ধকার হওয়ার পরিবর্তে জেনারেটর থেকে বিদ্যুৎ ব্যবহার করে। লাইফ-সাপোর্ট মেশিনে থাকা রোগীদের জন্য এটি খুবই ভালো ব্যাপার, যাদের বিদ্যুতের প্রয়োজন। সম্পূর্ণ ব্যর্থতা বিপজ্জনক, তাই ব্যাকআপ পরিকল্পনা গুরুত্বপূর্ণ।

এটি মূলত বেসিক প্রোগ্রামিং। ইনপুট সংজ্ঞায়িত করা। ভেরিয়েবল সেট করা। কাঙ্ক্ষিত আউটপুটগুলির দিকে পরিচালিত প্রক্রিয়া তৈরি করা। ফ্লোচার্টের মতো সেই প্রক্রিয়াগুলির মাধ্যমে চিন্তা করা, প্রয়োজনে শর্তাধীন বিবৃতি এবং ব্যতিক্রম যোগ করা। যদি সবকিছু ঠিকঠাক হয়, আপনি ইনপুট সরবরাহ করেন, প্রোগ্রামটি চালান এবং কাঙ্ক্ষিত আউটপুট পান।

এটি একটি অত্যন্ত জটিল কার্যকলাপের একটি বিশাল সরলীকরণ, তবে প্রোগ্রামিংয়ের জন্য নতুন এমন কারও জন্য এটি যথেষ্ট বিস্তারিত। এইভাবে প্রোগ্রামিংকে পুনর্গঠন করে, কোথায় শুরু করতে হবে তা জানা সহজ।

**প্রোগ্রামিং ভাষা**

এখানেই কঠিন অংশ: কম্পিউটার মানুষের মতো একই ভাবে ভাষা বলে না। মূল অংশে, কম্পিউটারগুলি খুব নির্দিষ্ট উপায়ে ক্ষুদ্র ইলেকট্রনিক সুইচ চালু এবং বন্ধ করে কাজ করে। যদি কম্পিউটারের আমাদের মানব-ভাষার কমান্ডগুলিকে ইলেকট্রনিক সুইচ-ফ্লিপিংয়ে অনুবাদ করার কোনও উপায় না থাকে, তবে কম্পিউটার আমরা যা আদেশ করি তা করতে সক্ষম হবে না।

প্রোগ্রামিং ভাষাগুলি তাই করে: তারা একজন মানব প্রোগ্রামারকে কখন শুরু করতে হবে, কী করতে হবে এবং কখন থামতে হবে তা কম্পিউটারকে বলার জন্য একটি নির্দিষ্ট উপায় দেয়। তারা প্রোগ্রামারকে ইনপুট, প্রক্রিয়া এবং আউটপুটগুলি কেমন দেখাচ্ছে এবং প্রোগ্রামটি চালানো শেষ হলে কী করতে হবে তাও সংজ্ঞায়িত করতে দেয়।

প্রতিটি প্রোগ্রামিং ভাষার কমান্ড লেখার একটি নির্দিষ্ট উপায় রয়েছে, যাকে সিনট্যাক্স বলা হয়। ভাষার সিনট্যাক্সে নিয়ম থাকে যা কম্পিউটার প্রোগ্রাম কমান্ডগুলিকে ক্ষুদ্র ইলেকট্রনিক সুইচ-ফ্লিপে অনুবাদ করতে ব্যবহার করে।

প্রায় প্রতিটি ভাষার ভেরিয়েবল, শর্তাধীন বিবৃতি এবং ব্যতিক্রম সংজ্ঞায়িত করার একটি উপায় রয়েছে। বিবরণ ভিন্ন হয়, তবে মূল ধারণাগুলি একই থাকে।

**একজন প্রোগ্রামারের মতো চিন্তা করা**

প্রোগ্রামাররা প্রায়শই ছদ্মকোড নামক একটি সমস্যা নিয়ে চিন্তা করেন: এমন ভাষা যা কোডের মতো দেখাচ্ছে বা শোনাচ্ছে, তবে কম্পিউটার দ্বারা আসলে কার্যকর করার জন্য যথেষ্ট নির্দিষ্ট নয়। এটিকে স্কেচিংয়ের একটি রূপ হিসাবে মনে করুন।

ছদ্মকোড আপনাকে কোনও সমস্যা সমাধানের প্রক্রিয়া নিয়ে চিন্তা করতে সহায়তা করে। আমি যে ড্রাইভিং উদাহরণটি ব্যবহার করছি তা ছদ্মকোডের একটি উদাহরণ। আমি যদি আমার গাড়িতে উঠে জোরে বলি, "যদি আমি চাবি ঘুরাই, তবে ইঞ্জিন চালু করুন", তবে কিছুই ঘটবে না। এর মানে এই নয় যে বিবৃতিটি অকেজো। বিবৃতিটি কেবল কোনও সমস্যা সমাধান করতে বা কাঙ্ক্ষিত ফলাফল পেতে প্রয়োজনীয় পদক্ষেপগুলি নিয়ে চিন্তা করার একটি উপায়।

আমরা এইমাত্র আলোচনা করা মৌলিক প্রোগ্রামিং ধারণাগুলি ব্যবহার করে, আপনি সাধারণ কাজের জন্য কিছু সাধারণ প্রোগ্রাম স্কেচ করতে পারেন।

এটি নিজে চেষ্টা করার একটি মজার উপায় এখানে দেওয়া হল। একজন বন্ধুকে খুঁজুন এবং তাকে "স্যান্ডউইচ তৈরি করা"-এর মতো একটি সাধারণ কাজ সম্পূর্ণ করতে সহায়তা করতে বলুন। একমাত্র নিয়ম হল আপনার বন্ধুকে আপনি তাকে যা বলবেন ঠিক তাই করতে হবে, এর বেশি কিছু নয়। তাকে কোনও কিছু সম্পর্কে জ্ঞানের অধিকারী ধরে নেওয়ার অনুমতি দেওয়া হয় না এবং প্রতিটি অনুরোধ আক্ষরিক অর্থে নিতে হয়।

কয়েক মিনিটের মধ্যে, আপনি নিজেকে এইরকম একটি কথোপকথন করতে দেখবেন:

আপনি: রুটিটা তোলো।
বন্ধু: আমি "তোলো" বুঝতে পারছি না।
আপনি: যেখানে আমি বলছি সেখানে আপনার হাত সরান এবং ধরুন।
বন্ধু: আমি "হাত" বুঝতে পারছি না।
আপনি: (দীর্ঘশ্বাস) এই জিনিসটা। [আপনি বন্ধুর হাত দেখান।]
বন্ধু: বুঝেছি।
আপনি: যেখানে আমি বলছি সেখানে আপনার হাত সরান এবং ধরুন।
বন্ধু: আমি "ধরুন" বুঝতে পারছি না।
আপনি: এইভাবে আপনার আঙুলগুলি বাঁকুন। [আপনি আপনার আঙুল বাঁকিয়ে এবং ছেড়ে দিয়ে দেখান।]
বন্ধু: বুঝেছি।
আপনি: রুটির দিকে আপনার হাত সরান এবং ধরুন।
বন্ধু: আমি "রুটি" বুঝতে পারছি না।
আপনি: এই জিনিসটা! [আপনি রুটি দেখান।]
বন্ধু: বুঝেছি।
আপনি: রুটির দিকে আপনার হাত সরান এবং ধরুন।
বন্ধু: [রুটির দিকে হাত সরায়, আঙুল বাঁকায় এবং ছেড়ে দেয়। রুটি নড়ে না।]
আপনি: এটা একটা বাজে খেলা!!!

এটি একটি নির্বোধ উদাহরণ, তবে এটি প্রোগ্রামিং দেখতে এবং অনুভব করার খুব কাছাকাছি, বিশেষ করে শুরুতে।

কম্পিউটার, আপনার বন্ধুর মতো, আপনি স্পষ্টভাবে সংজ্ঞায়িত না করলে কিছুই বুঝতে পারে না। আপনি যে কোনও জটিল প্রক্রিয়া সংজ্ঞায়িত করার চেষ্টা করেন, তা সম্পূর্ণরূপে এবং দ্ব্যর্থহীনভাবে নির্দিষ্ট করা প্রয়োজন।

এটি প্রোগ্রামিংকে কঠিন করে তোলে: একটি একক অস্পষ্টতা বা ভুল কমান্ড পুরো প্রোগ্রামটিকে ব্যর্থ করে দিতে পারে। প্রোগ্রামিং এই ক্ষেত্রে একটি ক্ষমাহীন কারুশিল্প: আপনার কোড হয় সঠিক বা ভুল, এবং অবশ্যই সঠিক বিশদ বিবরণে প্রকাশ করতে হবে।

কম্পিউটারগুলি আকর্ষণ বা বুদ্ধিমত্তা দ্বারা প্রভাবিত হয় না। যদি আপনার কোড অসম্পূর্ণ বা ত্রুটিপূর্ণ হয়, তবে আপনার অ্যাপ্লিকেশনটি ক্র্যাশ হবে, আপনি ডেটা হারাবেন এবং/অথবা আপনি একটি বাগ তৈরি করবেন: এক ধরণের দুর্বৃত্ত কোড যা অপ্রত্যাশিত বা অপ্রত্যাশিত পরিণতি তৈরি করে। গণিতের মতো, যুক্তি হয় কাজ করে বা করে না। প্রচেষ্টার জন্য কোনও A নেই।

বলা বাহুল্য, প্রোগ্রামিংয়ে কোনও নির্দিষ্ট সমস্যার জন্য কোনও একক সর্বজনীন সমাধান নেই, যেমন গণিতে রয়েছে। নির্দিষ্ট ইনপুট দেওয়া হলে আপনার কাঙ্ক্ষিত আউটপুট তৈরি করার হাজার হাজার উপায় রয়েছে। একজন প্রোগ্রামার হিসাবে, আপনার কাছে থাকা সরঞ্জামগুলির উপর ভিত্তি করে আপনি আপনার পদ্ধতি চয়ন করতে পারেন।

একবার আপনি অভ্যস্ত হয়ে গেলে যে কম্পিউটার আপনার মন পড়তে পারে না, আপনি এমন কমান্ড দেওয়া শুরু করেন যা সিস্টেম বুঝতে পারে, একইভাবে আপনি জটিল কমান্ড দেওয়ার আগে "স্যান্ডউইচ গেমে" আপনার বন্ধুকে স্পষ্টভাবে শর্তাদি সংজ্ঞায়িত করতে এবং মৌলিক ক্রিয়া প্রদর্শন করতে শিখিয়েছিলেন।

**ওয়েব অ্যাপ্লিকেশন প্রোগ্রামিংকে কী আলাদা করে তোলে?**

আমাদের এখন প্রোগ্রামিংয়ের একটি কার্যকরী সংজ্ঞা রয়েছে। এটি খুব সরলীকৃত, তবে আপাতত আমরা কী করার চেষ্টা করছি সে সম্পর্কে এটি যথেষ্ট ভালো ধারণা দেয়।

তবে, আমি সব ধরণের প্রোগ্রামিংয়ে আগ্রহী নই: আমি এমন প্রোগ্রাম লিখতে চাই যা ওয়েবসাইটে চলে। আপনি যদি Gmail, Hotmail, Yahoo Mail বা এই জাতীয় কোনও ওয়েব-ভিত্তিক ইমেল প্রোগ্রাম ব্যবহার করে থাকেন তবে আপনি জানেন আমি কী বলছি। এই প্রোগ্রামগুলি আপনার ইন্টারনেট ব্রাউজারে চলে। এগুলি ব্যবহার করার জন্য আপনাকে আপনার কম্পিউটারে কোনও সফ্টওয়্যার প্রোগ্রাম ডাউনলোড করতে হবে না। আপনি কেবল আপনার ব্রাউজারটিকে ওয়েবসাইটে নির্দেশ করেন, লগ ইন করেন এবং আপনি যেতে প্রস্তুত।

স্থানীয়ভাবে চলমান সফ্টওয়্যার এবং কোনও ওয়েব সার্ভারে দূরবর্তীভাবে চলমান সফ্টওয়্যারের মধ্যে এই পার্থক্যটি গুরুত্বপূর্ণ। একটি ওয়েব অ্যাপ্লিকেশন বিকাশ করতে, আপনাকে প্রথমে অ্যাপ্লিকেশনটি লিখতে হবে এবং তারপরে এটি কাজ করে কিনা তা দেখার জন্য পরীক্ষা করতে হবে। সমস্ত বিকাশ এবং পরীক্ষা আপনার নিজের কম্পিউটারে ঘটে।

প্রোগ্রামটি কাজ করার পরে, আপনি এটি "প্রোডাকশন" ওয়েব সার্ভারে পাঠান যাতে অন্যান্য লোকেরা এটি অ্যাক্সেস করতে পারে। ইন্টারনেটের লোকেরা ওয়েব থেকে আপনার ব্যক্তিগত কম্পিউটারে লগ ইন করতে পারে না, তাই অন্যান্য লোকেদের আপনার প্রোগ্রামটি ব্যবহার করার জন্য সর্বজনীনভাবে অ্যাক্সেসযোগ্য ওয়েব সার্ভারে সফ্টওয়্যার আপলোড করা প্রয়োজন।

এর অর্থ হল বিকাশ প্রক্রিয়ার দুটি প্রধান পর্যায় রয়েছে: স্থানীয় প্রোগ্রামিং এবং টেস্টিং, এবং প্রকৃত ব্যবহারের জন্য একটি দূরবর্তী প্রোডাকশন সার্ভারে সমাপ্ত প্রোগ্রামটি পুশ করা। আমাকে বের করতে হবে এই দুটি পর্যায় কীভাবে কাজ করে।

HTML এবং CSS-এর সাথে আমার পূর্ববর্তী অভিজ্ঞতা থেকে আমি আরও কিছু জানি: এগুলি "বোবা", এই অর্থে যে আপনি কোনও বেসিক ওয়েব পেজকে কোনও তথ্য সঞ্চয় করতে বলতে পারবেন না।

ধরুন আপনার কাছে একটি ওয়েব পেজ ফাইল আছে যাতে লেখা আছে, "Hello, World!" এবং আপনি "World"-এর পরিবর্তে পেজটি ভিজিট করা ব্যক্তির নাম প্রতিস্থাপন করতে চান। এটি একটি সুন্দর চিন্তা, তবে বেসিক ওয়েব পেজগুলির পরে ব্যবহারের জন্য কোনও তথ্য সঞ্চয় করার কোনও উপায় নেই। তারা কেবল ফাইলের টেক্সট প্রদর্শন করে এবং ফাইলটিকে নিজেকে আপডেট করার অনুমতি দেওয়া হয় না।

এর প্রযুক্তিগত শব্দ হল স্টেট। HTML এবং CSS ব্যবহার করে নির্মিত বেসিক ওয়েব পেজগুলির কোনও স্টেট নেই, তাই এগুলিকে "স্টেটলেস" রিসোর্স হিসাবে উল্লেখ করা হয়। আপনি একটি ওয়েব পেজে একটি ছোট ফর্ম যুক্ত করতে পারেন যা ব্যবহারকারীর নাম জিজ্ঞাসা করে এবং এর পাশে একটি Save বোতাম থাকে, তবে সেই বোতামটি আসলে কোনও তথ্য সংরক্ষণ করবে না যদি না আপনি সেই তথ্যটি যাওয়ার জন্য একটি পৃথক স্থান তৈরি করেন।

এজন্য ওয়েব অ্যাপ্লিকেশনগুলি পরে ডেটা সংরক্ষণ করার জন্য দুটি সাধারণ পদ্ধতি ব্যবহার করে: ডাটাবেস এবং কুকিজ।

ডাটাবেস কী করে তা বোঝার সেরা উপায় হল ইনডেক্স কার্ডের একটি স্তূপ কল্পনা করা। ধরুন আপনি একটি ঠিকানা বই তৈরি করার চেষ্টা করছেন এবং আপনি আপনার বন্ধুদের প্রত্যেকের নাম, ফোন নম্বর, ইমেল ঠিকানা, লিঙ্গ এবং বয়স ক্যাপচার করতে চান।

প্রতিটি বন্ধুর নিজস্ব ইনডেক্স কার্ড থাকে এবং তাদের তথ্য সেই কার্ডে রেকর্ড করা হয়। উদাহরণস্বরূপ, যদি আপনার কোনও বন্ধু তাদের ইমেল ঠিকানা পরিবর্তন করে, তবে আপনি পুরানো তথ্য মুছে ফেলতে এবং নতুন তথ্য দিয়ে কার্ডটি আপডেট করতে পারেন। আপনি যখন কোনও নির্দিষ্ট বন্ধুর কার্ড দেখেন, তখন আপনি একবারে তাদের সমস্ত তথ্য দেখতে পারেন।

আপনি ইনডেক্স কার্ডের পুরো স্তূপটিকে একটি ডাটাবেস হিসাবে ভাবতে পারেন। স্ট্যাকের প্রতিটি কার্ডকে একটি রেকর্ড বলা হয়। ডাটাবেসে আপনার যত খুশি রেকর্ড থাকতে পারে, তবে কোনও এক সময়, স্ট্যাকটি পরিচালনা করা কঠিন হয়ে পড়ে। প্রায়শই স্ট্যাকটিকে কয়েকটি ছোট সাবস্ট্যাকে বিভক্ত করা যুক্তিযুক্ত: একটি স্ট্যাকে বন্ধু এবং পরিবার, অন্যটিতে কাজ থেকে আসা সহকর্মী, উদাহরণস্বরূপ।

এতদূর পরিষ্কার? এখানে এটি আকর্ষণীয় হয়ে ওঠে: কল্পনা করুন আপনার ইনডেক্স কার্ডের স্তূপটি এখন একটি জাদুকরী স্তূপ। আপনি জাদুকরী স্তূপের সাথে কথা বলতে পারেন এবং সেগুলিকে নির্দিষ্ট শর্তের সাথে মানানসই কার্ডগুলি দেখাতে আদেশ দিতে পারেন, যেমন "আমাকে জন স্মিথের কার্ড দেখাও"।

"আমাকে সেই সমস্ত কার্ড দেখাও যেখানে লিঙ্গ মহিলা"।

"আমাকে সেই সমস্ত কার্ড দেখাও যেখানে বয়স পঞ্চাশের বেশি"।

বেশ দরকারী, তাই না? মূলত, ডাটাবেসগুলি তাই করে: তারা আপনাকে কাঠামোগত তথ্য সংরক্ষণ করার একটি উপায় দেয়, সেইসাথে আপনি যখন চান তখন সেই তথ্যটি পুনরুদ্ধার করার একটি উপায় দেয়।

আমরা কার্ডে যে ডেটা রাখি তার প্রতিটি অংশকে একটি ক্ষেত্র বলা হয়। আপনার ডাটাবেসে যত বেশি ক্ষেত্র থাকবে, আপনি যখন চান তখন ডেটা পুনরুদ্ধার করার তত বেশি উপায় আপনার থাকতে পারে।

ওয়েব অ্যাপ্লিকেশনে ডেটা সংরক্ষণ করার সবচেয়ে সাধারণ উপায় হল ডাটাবেস। আপনি যদি ব্যবহারকারীর নাম, ইমেল ঠিকানা এবং অন্যান্য তথ্যের মতো তথ্য সংরক্ষণ করতে চান তবে ডাটাবেস ব্যবহার করা একটি স্বাভাবিক পদ্ধতি। একবার জন স্মিথ আপনার অ্যাপ্লিকেশনে লগ ইন করলে, আপনি জন-এর ডাটাবেস রেকর্ড থেকে নামটি পুনরুদ্ধার করতে এবং "Hello, John Smith!" প্রদর্শন করতে আপনার অ্যাপ্লিকেশনটিকে ব্যবহার করতে পারেন।

ওয়েব অ্যাপ্লিকেশনে তথ্য সংরক্ষণ করার অন্য সাধারণ উপায় হল কুকি ব্যবহার করা: একটি খুব ছোট টেক্সট ফাইল যা ব্যবহারকারীর কম্পিউটারে সংরক্ষিত থাকে। কুকি অল্প পরিমাণে ডেটা সংরক্ষণ করার জন্য দরকারী যা খুব বেশি দিন ধরে রাখার প্রয়োজন হয় না।

আমাদের ঠিকানা বই প্রোগ্রামের ক্ষেত্রে, জন স্মিথ লগ ইন করলে একটি কুকি সংরক্ষণ করা উপযুক্ত হবে। জন-এর কুকি ফাইলে username = johnsmith এবং loggedin = true-এর মতো তথ্য থাকবে। যদি স্মিথ অ্যাপ্লিকেশনটি ছেড়ে যায়, তবে পরে ফিরে আসে, অ্যাপ্লিকেশনটি কুকিটিকে চিনতে পারবে এবং অন্য লগইন না করেই তাকে অ্যাক্সেস দেবে। কুকিগুলি একটি নির্দিষ্ট সময়ের মধ্যে শেষ হওয়ার জন্য সেট করা যেতে পারে, যা এ জাতীয় প্রোগ্রামিংয়ের জন্য তাদের সুবিধাজনক করে তোলে। (আপনি যদি কোনও ওয়েবসাইটে "Remember this password" বৈশিষ্ট্য দেখে থাকেন তবে এটি এভাবেই কাজ করে।)

আমরা এখানে যা করছি তা হল বেসিক ডিকনস্ট্রাকশন। ওয়েব প্রোগ্রামিংকে যা অনন্য করে তোলে তার এটি সম্পূর্ণ তালিকা নয়, তবে এটি শেখার জন্য আমার প্রয়োজনীয় বিষয়গুলির একটি সহজ কাঠামো সরবরাহ করার জন্য যথেষ্ট সম্পূর্ণ: ভেরিয়েবল, শর্তাধীন বিবৃতি, ব্যতিক্রম, স্থানীয়/প্রোডাকশন পরিবেশ, ডাটাবেস এবং কুকিজ।

দেখুন এই বিশ্লেষণটি কতটা দরকারী? আমি যা করতে চেয়েছিলাম তার একটি খুব অস্পষ্ট ধারণা দিয়ে শুরু করেছি এবং এখন আমার কাছে মূল উপ-দক্ষতার একটি নির্দিষ্ট তালিকা রয়েছে যা শেখা গুরুত্বপূর্ণ।

তবে, আমি এখনও ঝাঁপিয়ে পড়ার জন্য প্রস্তুত নই। মনে রাখবেন আমি উল্লেখ করেছি যে কম্পিউটার মানুষের ভাষা বুঝতে পারে না? আমার প্রোগ্রামটির নির্দেশাবলী লেখার জন্য আমাকে একটি প্রোগ্রামিং ভাষা চয়ন করতে হবে, যার জন্য আরও কিছুটা গবেষণার প্রয়োজন হবে।

**ওয়েব অ্যাপ্লিকেশন প্রোগ্রামিংয়ের জন্য একটি ভাষা নির্বাচন করা**

বাজারে হাজার হাজার বিভিন্ন প্রোগ্রামিং ভাষা উপলব্ধ এবং প্রতিদিন নতুন ভাষা উদ্ভাবিত হচ্ছে। প্রতিটি ভাষার সিনট্যাক্স আলাদা এবং ভাষাটি কী অর্জন করার জন্য ডিজাইন করা হয়েছে তার দ্বারা ব্যাপকভাবে প্রভাবিত। কিছু ভাষা অন্যদের তুলনায় নির্দিষ্ট কাজের জন্য বেশি অপ্টিমাইজ করা হয়েছে।

ঝাঁপিয়ে পড়ার আগে, আমি কয়েকটি প্রধান প্রোগ্রামিং ওয়েবসাইট ঘুরে দেখতে এক ঘন্টা সময় দেওয়ার সিদ্ধান্ত নিয়েছিলাম যাতে কর্মরত ওয়েব অ্যাপ্লিকেশন ডেভেলপাররা কোন ভাষা শেখার পরামর্শ দেন তা দেখতে। এই প্রাথমিক গবেষণা আমাকে কোন ভাষা শিখতে হবে এবং কোন প্রাথমিক দক্ষতা অনুশীলন করতে হবে তা সিদ্ধান্ত নিতে সাহায্য করবে।

প্রোগ্রামারদের জন্য দুটি জনপ্রিয় গন্তব্য হল Stack Overflow এবং Hacker News, তাই আমি শেখার জন্য সেরা ভাষা সম্পর্কে পরামর্শের জন্য ব্রাউজ করা শুরু করি।

Stack Overflow একটি প্রশ্নোত্তর ওয়েবসাইট: "আমি কীভাবে X করব?" এই জাতীয় প্রশ্ন জিজ্ঞাসা করার একটি জায়গা। আরও জ্ঞানী এবং অভিজ্ঞ কোডাররা সাধারণত নির্দিষ্ট পরামর্শ, পদ্ধতি বা বাগ ফিক্স সহ প্রশ্নের উত্তর দেন, যা জটিল প্রোগ্রামিং সমস্যাগুলিতে সহায়তা পাওয়ার জন্য Stack Overflow-কে সেরা গন্তব্য করে তোলে।

Hacker News একটি সামাজিক সংবাদ ওয়েবসাইট: সম্পর্কিত আলোচনা সহ লিঙ্কগুলির একটি সংগ্রহ। Hacker News-এর বিষয়গুলি মিনিটে মিনিটে পরিবর্তিত হয়, তবে সাধারণত প্রোগ্রামিং, প্রযুক্তি এবং ব্যবসায়ের নতুন উন্নয়নকে কেন্দ্র করে, যা প্রোগ্রামিংয়ের নতুন উন্নয়ন সম্পর্কে কমপক্ষে আধা-জ্ঞাত মতামত ব্রাউজ করার জন্য Hacker News-কে একটি আদর্শ জায়গা করে তোলে।

বিশ্বজুড়ে প্রোগ্রামারদের দ্বারা প্রতিদিন নতুন ভাষা, লাইব্রেরি এবং কৌশল তৈরি করা হয়। প্রযুক্তি এবং পদ্ধতির কিছু সংমিশ্রণ কিছু সমস্যার জন্য দরকারী এবং অন্যরা নয়। প্রায়শই, আপনি চেষ্টা না করা পর্যন্ত বলতে পারবেন না।

প্রোগ্রামিংয়ের ক্ষেত্রে "সেরা" শব্দটি আপনি যে সমস্যাটি সমাধান করার চেষ্টা করছেন এবং আপনার নির্দিষ্ট অগ্রাধিকারগুলির সাথে সম্পর্কিত। সাধারণভাবে, পরামর্শ হল (১) এমন সরঞ্জাম চয়ন করুন যা আপনাকে দক্ষতার সাথে সমস্যাটি সমাধান করতে দেয় এবং (২) যদি আপনার পছন্দ থাকে, তবে এমন সরঞ্জাম চয়ন করুন যা আপনি ব্যবহার করে উপভোগ করেন। যথেষ্ট ন্যায্য।

Stack Overflow এবং Hacker News-এর আর্কাইভ ব্রাউজ করা আমাকে প্রচুর তথ্যের ভারে জর্জরিত করে দিয়েছিল: একবারে প্রক্রিয়া করার জন্য খুব বেশি তথ্য ছিল, বিশেষ করে যদি আপনি পরিভাষাটির সাথে পরিচিত না হন। আমি যদি আরও নির্দিষ্ট পরামর্শ খুঁজে পেতে চাই তবে আমার এই গোলমাল কমাতে হবে।

এখানে একটি কৌশলগত গবেষণা কৌশল দেওয়া হল যা বেশিরভাগ লোক জানেন না: জনপ্রিয় সার্চ ইঞ্জিনগুলি আপনাকে পুরো ওয়েবের পরিবর্তে একটি নির্দিষ্ট ওয়েবসাইটে আপনার অনুসন্ধান সীমাবদ্ধ করতে দেয়। Google-এ এটি করার কোডটি এইরকম:

"অনুসন্ধান শব্দগুচ্ছ" site:example.com

"অনুসন্ধান শব্দগুচ্ছ"-এর জায়গায় আপনি যে শব্দটি অনুসন্ধান করছেন সেটি এবং "example.com"-এর জায়গায় আপনি যে ওয়েবসাইটটি অনুসন্ধান করতে চান সেটি প্রতিস্থাপন করুন। উদ্ধৃতি চিহ্নগুলির অর্থ হল অনুসন্ধান শব্দগুচ্ছের সঠিক মিলগুলি অনুসন্ধান করা। উদ্ধৃতি চিহ্নগুলি ছাড়া, Google সেই শব্দগুচ্ছের সমস্ত শব্দ ধারণ করে এমন পৃষ্ঠাগুলি ফেরত দেবে, তবে প্রয়োজনীয় নয় যে সেই ক্রমে।

এই কৌশলটি ব্যবহার করে, আমি "ওয়েব অ্যাপ্লিকেশন প্রোগ্রামিং", "কোড শিখুন" এবং "নতুনদের জন্য প্রোগ্রামিং" শব্দগুচ্ছগুলির বিভিন্ন রূপ অনুসন্ধান করেছি, তারপর ফলাফলগুলি পড়তে আরও এক ঘন্টা বা তার বেশি সময় ব্যয় করেছি।

আমি যা খুঁজে পেয়েছি তা এখানে দেওয়া হল: অভিজ্ঞ ওয়েব ডেভেলপাররা বর্তমানে দুটি সাধারণ ভাষার মধ্যে একটি দিয়ে শুরু করার পরামর্শ দেন: রুবি বা পাইথন। রুবি এবং পাইথন, খ্যাতি অনুসারে, শেখা তুলনামূলকভাবে সহজ, শক্তিশালী এবং আপনাকে গুরুত্বপূর্ণ প্রোগ্রামিং ধারণাগুলির একটি ভাল ভিত্তি দেয়। রুবি ওয়েব অ্যাপ্লিকেশনগুলিতে ফোকাস করা প্রোগ্রামারদের মধ্যে কিছুটা বেশি জনপ্রিয়, যেখানে পাইথন বিজ্ঞানী এবং গণিতবিদদের মধ্যে বেশি জনপ্রিয়, কারণ এতে বিভিন্ন ধরণের বিজ্ঞান, গণিত এবং গ্রাফিং লাইব্রেরি রয়েছে।

রুবি এবং পাইথন উভয়েরই ডেভেলপারদের সক্রিয় সম্প্রদায়, প্রচুর বিনামূল্যের উপলব্ধ সংস্থান এবং ভালভাবে লেখা বই এবং পূর্ব-বিদ্যমান প্রোগ্রাম এবং সরঞ্জাম রয়েছে যা গুরুত্বপূর্ণ বৈশিষ্ট্যগুলি বাস্তবায়ন করা সহজ করে তোলে। কোন ভাষার সাথে কাজ করতে হবে তা বেছে নেওয়া মূলত পছন্দের বিষয় বলে মনে হয়।

এই ভাষাগুলির প্রতিটিতে লেখা কোডের কয়েকটি উদাহরণ পড়ার পরে, আমি রুবি শেখার সিদ্ধান্ত নিয়েছি। আমার অপটু চোখে, রুবি কোড পরিষ্কার, পঠনযোগ্য এবং তুলনামূলকভাবে বোঝা সহজ বলে মনে হয়। যেহেতু রুবি ব্যবহার করে আমি যে প্রধান ধারণা এবং কৌশলগুলি শিখব তা অন্যান্য ভাষায় স্থানান্তরিত হবে যা আমি পরে শেখার সিদ্ধান্ত নিতে পারি, তাই আমি শুরু থেকেই শেখার প্রক্রিয়াটিকে আনন্দদায়ক করতে পারি।

এছাড়াও, এমন বেশ কয়েকটি প্রোগ্রাম এবং সরঞ্জাম রয়েছে যা আমি ব্যবহার করতে চাই যা রুবি সমর্থন করে বা প্রয়োজন করে। বিশেষত, জেকিল রুবিতে লেখা, তাই রুবি শেখা আমাকে একটি জরুরি সমস্যা সমাধানে সহায়তা করবে। পাইথনের জন্য অনুরূপ সরঞ্জাম বিদ্যমান, তবে সেগুলি ব্যবহার করা আরও জটিল বলে মনে হয়।

**একটি ফ্রেমওয়ার্ক নির্বাচন করা**

প্রোগ্রামিং ভাষার পরামর্শের পাশাপাশি, কর্মরত ওয়েব অ্যাপ্লিকেশন প্রোগ্রামারদের ফ্রেমওয়ার্ক সম্পর্কেও দৃঢ় মতামত রয়েছে: কোডের লাইব্রেরি যা বেশিরভাগ অ্যাপ্লিকেশনকে যা করতে হয় তা করা সহজ করে তোলে।

লাইব্রেরিগুলি গুরুত্বপূর্ণ কারণ কম্পিউটারগুলি ঠিক তাই করে যা আপনি তাদের করতে বলেন। এর বেশিও না, এর কমও না।

এটি জটিল, কারণ আপনার দেওয়া কোডই কম্পিউটার প্রোগ্রামের জন্য বিদ্যমান সবকিছু। এটি বিখ্যাত পদার্থবিজ্ঞানী কার্ল সাগানের উদ্ধৃতির মতো: "আপনি যদি স্ক্র্যাচ থেকে একটি আপেলের পাই তৈরি করতে চান, তবে আপনাকে প্রথমে মহাবিশ্বের উদ্ভাবন করতে হবে।"

আপনার প্রোগ্রামের "মহাবিশ্ব" সংজ্ঞায়িত করা হয় (১) কোডবেসের নির্দেশাবলী এবং কমান্ড, (২) আপনার প্রোগ্রাম যে লাইব্রেরিগুলি আমদানি করে এবং (৩) প্রোগ্রামটি যে সিস্টেমে চলছে তার দ্বারা। কোনও প্রদত্ত অপারেশন সম্পূর্ণ করার জন্য প্রয়োজনীয় কোড যদি সিস্টেমে কোথাও বিদ্যমান না থাকে তবে আপনার প্রোগ্রামটি ক্র্যাশ করবে বা একটি ত্রুটি ফেরত দেবে।

বেশিরভাগ প্রোগ্রামিং ভাষায় অনেক সাধারণ লাইব্রেরি থাকে যা বেশিরভাগ প্রোগ্রামের প্রয়োজন, তবে খুব কম বিশেষায়িত সরঞ্জাম থাকে
। এখানেই ফ্রেমওয়ার্কগুলি কাজে আসে। স্ক্র্যাচ থেকে সবকিছু কোড করার পরিবর্তে, যা অনেক সময় নেবে, একটি ফ্রেমওয়ার্ক ব্যবহার করে আপনি বিশেষায়িত কাজের জন্য পরীক্ষিত, নির্ভরযোগ্য লাইব্রেরি আমদানি এবং ব্যবহার করতে পারেন, যা আপনাকে মহাবিশ্বের পুনঃউদ্ভাবনের পরিবর্তে আপনার অ্যাপ্লিকেশনের মূল অংশে মনোযোগ দিতে দেয়।

ফ্রেমওয়ার্কগুলি বড় বা ছোট হতে পারে। কিছু ফ্রেমওয়ার্কে প্রোগ্রামারের প্রচেষ্টা বাঁচানোর জন্য অনেকগুলি ফাংশন এবং কমান্ড অন্তর্ভুক্ত থাকে এবং অন্যরা আরও সংক্ষিপ্ত, কেবল কয়েকটি প্রয়োজনীয় ফাংশন কভার করে।

এই মুহুর্তে, রুবি বেশ কয়েকটি প্রধান ওয়েব অ্যাপ্লিকেশন ডেভেলপমেন্ট ফ্রেমওয়ার্কের গর্ব করে, যার মধ্যে দুটি সবচেয়ে জনপ্রিয়: রুবি অন রেলস এবং সিনাত্রা।

রুবি অন রেলস (প্রায়শই কেবল রেলস নামে পরিচিত) রুবিতে ডেভেলপ করা প্রথম প্রধান ওয়েব অ্যাপ্লিকেশন ফ্রেমওয়ার্কগুলির মধ্যে একটি। ডেভিড হেইনমিয়ার হ্যানসন ২০০৪ সালে তৈরি করেন, রেলস সহজেই সবচেয়ে জনপ্রিয় রুবি ফ্রেমওয়ার্ক এবং হ্যানসন যেখানে অংশীদার, সেই ব্যক্তিগত ওয়েব অ্যাপ্লিকেশন কোম্পানি ৩৭সিগন্যালসে বেশ কয়েকটি সফল অ্যাপ্লিকেশন ডেভেলপ করতে এটি ব্যবহৃত হয়েছিল। আজ অবধি, হাজার হাজার ব্যবসা রেলস ব্যবহার করে বৃহৎ ব্যবসায়িক-গুরুত্বপূর্ণ ওয়েব অ্যাপ্লিকেশন ডেভেলপ করেছে।

রেলস "জেনারেটর"-এর উপর ব্যাপকভাবে নির্ভর করে: বিল্ট-ইন প্রোগ্রাম যা একটি একক কমান্ডের মাধ্যমে প্রচুর পরিমাণে বয়লারপ্লেট কোড তৈরি করে। বয়লারপ্লেটটি তখন প্রোগ্রামারের অনন্য প্রয়োজনীয়তার উপর ভিত্তি করে সংশোধন করা হয়। স্ক্র্যাচ থেকে একটি অ্যাপ্লিকেশন তৈরি করতে ঘন্টাখানেক ব্যয় করার পরিবর্তে, রেলস ডেভেলপারদের খুব বেশি প্রচেষ্টা ছাড়াই একটি কার্যকরী অ্যাপ্লিকেশন তৈরি করতে সাহায্য করে, যদি তারা জানে তারা কী করছে।

অন্যদিকে, সিনাত্রা হল ব্লেক মিজেরানি দ্বারা ডিজাইন ও ডেভেলপ করা একটি সংক্ষিপ্ত ফ্রেমওয়ার্ক। জেনারেটরের উপর নির্ভর করার পরিবর্তে, সিনাত্রা ডেভেলপারকে কয়েকটি সরল সাধারণ ফাংশন দেওয়ার উপর মনোযোগ দেয় যা বেশিরভাগ ওয়েব অ্যাপ্লিকেশনের প্রয়োজন, তারপর পথ থেকে সরে যায়।

রেলস অ্যাপ্লিকেশনের তুলনায় সিনাত্রা অ্যাপ্লিকেশনগুলি দেখতে এবং অনুভব করতে সরল। রেলসের একটি একক কমান্ড দশ বা তার বেশি ফোল্ডার এবং বিশ বা তার বেশি ফাইল তৈরি করতে পারে। বিপরীতে, একটি সিনাত্রা অ্যাপ্লিকেশন সম্পূর্ণরূপে একটি একক ফাইলে অন্তর্ভুক্ত থাকা অস্বাভাবিক নয়। অপসারণের প্রয়োজন হতে পারে এমন প্রচুর কোড তৈরি করার পরিবর্তে, সিনাত্রা ডেভেলপমেন্ট প্রকল্পটিকে সরল রাখা এবং কাজটি করার জন্য যথেষ্ট কোড যোগ করার জন্য পুরস্কৃত করে।

একটি ভাষা বেছে নেওয়ার মতো, একটি ফ্রেমওয়ার্ক বেছে নেওয়া মূলত পছন্দের বিষয় এবং কাজের জন্য সেরা সরঞ্জাম নির্বাচন করা। রেলস একাধিক প্রোগ্রামার সহ বড় প্রকল্পের জন্য বেশি পছন্দের, এবং সিনাত্রা সাধারণত ছোট প্রকল্পের জন্য বেশি উপযুক্ত। অনেক ওভারল্যাপিং বৈশিষ্ট্য রয়েছে, তাই RubySource.com-এর একটি সাম্প্রতিক বিশ্লেষণ উপসংহারে পৌঁছেছে যে এটি শেষ পর্যন্ত একটি বিষয়ভিত্তিক পছন্দ।

গিটহাব একটি ওপেন সোর্স কোড রিপোজিটরি যা অনেক প্রোগ্রামার তাদের প্রকল্পগুলি প্রকাশ এবং রক্ষণাবেক্ষণ করতে ব্যবহার করে। প্রতিটি ফ্রেমওয়ার্কের ধারণা পেতে রেলস এবং সিনাত্রাতে লেখা অ্যাপ্লিকেশনগুলির উদাহরণ খুঁজে পাওয়া সহজ, তাই আমি আরও এক ঘন্টা পাবলিক প্রকল্প ব্রাউজ করেছি।

এখানে একটি তুচ্ছ ঝুঁকি রয়েছে: প্রোগ্রামিংয়ে অগ্রগতি করার জন্য, আপনাকে কিছুর প্রতি প্রতিশ্রুতিবদ্ধ হতে হবে। একবার আপনি একটি ভাষা এবং একটি ফ্রেমওয়ার্ক বেছে নিলে, একটি প্রোগ্রাম লেখার জন্য আপনার যা কিছু জানার দরকার তা শেখা শুরু করা অনেক সহজ। তবে, আপনি যদি পছন্দ করতে দ্বিধা করেন তবে আপনি "নিখুঁত" প্রোগ্রামিং পরিবেশ খুঁজে পেতে বছরের পর বছর ব্যয় করতে পারেন।

আপনার কাছে আকর্ষণীয় একটি ভাষা এবং ফ্রেমওয়ার্ক বেছে নেওয়া, কিছুক্ষণ এটির অন্বেষণে প্রতিশ্রুতিবদ্ধ হওয়া এবং অনিবার্য ট্রেডঅফগুলি গ্রহণ করা, বছরের পর বছর "গবেষণা" করে এবং শূন্য অগ্রগতি করার চেয়ে ভাল। সারাদিন Stack Overflow এবং Hacker News ব্রাউজ করা প্রোগ্রামিং নয়।

অবশেষে, আমি সিনাত্রা দিয়ে শুরু করার সিদ্ধান্ত নিয়েছি। যদিও আপনি কী করছেন তা জানলে রেলস জেনারেটর অনেক সময় বাঁচাতে পারে, আমি কী করছি তা জানি না।

আমার intuition আমাকে বলছে যে এই মুহুর্তে সিনাত্রা সেরা পছন্দ। সিনট্যাক্স পরিষ্কার, সরল এবং বোঝা সহজ। একটি সিনাত্রা অ্যাপে বিদ্যমান একমাত্র কোড হল ডেভেলপার যে কোড যোগ করে। ফ্রেমওয়ার্কটি ভালোভাবে ডকুমেন্ট করা আছে এবং গিটহাবে কার্যকরী অ্যাপ্লিকেশনগুলির উদাহরণ, সেইসাথে Stack Overflow-তে সাহায্য খুঁজে পাওয়া সহজ।

আমি ভবিষ্যতে কোনও সময়ে রেলস নিয়ে পরীক্ষা করতে পারি। আপাতত, আমি সিনাত্রা দিয়ে শুরু করছি।

**চূড়ান্ত ফলাফল পুনর্গঠন**

প্রায় পাঁচ ঘন্টা প্রাথমিক গবেষণা আমাকে শুরু করার জন্য প্রয়োজনীয় সবকিছু দিয়েছে: ওয়েব প্রোগ্রামিংয়ের একটি পুনর্গঠন, একটি ভাষা, একটি ফ্রেমওয়ার্ক এবং একটি নির্দিষ্ট প্রকল্প। এখন কাজ করার সময়।

"একটি সিনাত্রা অ্যাপ্লিকেশন কোড করুন যা একটি জেকিল ওয়েবসাইট পরিবেশন করে" একটি শালীন লক্ষ্য কর্মক্ষমতার স্তর উপস্থাপন করে, তবে এর পরে কী করতে হবে তা বের করার জন্য আমাকে সেই বিবৃতিটি কী কী নিয়ে গঠিত তা পুনর্গঠন করতে হবে। আমাকে কী করতে সক্ষম হতে হবে?

আরও এক ঘন্টা গবেষণা নিম্নলিখিত নির্ধারণ করে:

১. জেকিল চালানো স্থানীয় স্ট্যাটিক ফাইল থেকে সমাপ্ত ওয়েবসাইট তৈরি করে। আমাকে বিশেষ ফরম্যাটিং ট্যাগ সহ ওয়েবসাইটের জন্য একটি HTML টেমপ্লেট তৈরি করতে হবে এবং পল স্টামাটিও তৈরি করা একটি টিউটোরিয়ালে বর্ণিত PersonalMBA.com থেকে আমার পোস্টগুলির আর্কাইভ এক্সপোর্ট করতে হবে।

২. সিনাত্রা অ্যাপ্লিকেশন ওয়েবসাইট দর্শকদের কাছ থেকে অনুরোধগুলি পরিচালনা করে, অনুরোধ করা ফাইলগুলি সরবরাহ করে। আমাকে স্ক্র্যাচ থেকে এই অ্যাপ্লিকেশনটি লিখতে হবে।

৩. সমাপ্ত জেকিল ওয়েবসাইট এবং সিনাত্রা সার্ভার অ্যাপ্লিকেশন উভয়ই একটি ওয়েবসাইট হোস্টে আপলোড করতে হবে।

৪. এই সমস্ত কাজ সম্পন্ন করার জন্য, আমাকে আমার মেশিনে রুবি-এর সর্বশেষ সংস্করণ, সেইসাথে সিনাত্রা এবং আমার প্রয়োজনীয় অন্যান্য প্রোগ্রামগুলি কীভাবে ইনস্টল করতে হয় তা বের করতে হবে।

এই শেষ প্রয়োজনীয়তাটি সমালোচনামূলক সরঞ্জাম প্রাপ্তির একটি ভাল উদাহরণ। যদি আমি আমার মেশিনে রুবি ইনস্টল করতে না পারি, তবে আমি পরবর্তী কোনও পদক্ষেপ করতে পারব না, তাই এটি শুরু করার সেরা জায়গা।

এটি উল্লেখ করা গুরুত্বপূর্ণ যে ওয়েব প্রযুক্তি প্রতিদিন পরিবর্তিত হয়। সম্ভবত এই বিভাগের নির্দিষ্ট কমান্ডগুলির সিরিজ আপনি যখন এটি পড়বেন তখন অপ্রচলিত হয়ে যাবে। চিন্তা করবেন না: কমান্ডগুলি নয়, পদ্ধতিটি গুরুত্বপূর্ণ।

একইভাবে, আপনি এই অধ্যায়ের কোড বিভাগগুলি এড়িয়ে যেতে প্রলুব্ধ হবেন। এটি একটি স্বাভাবিক প্রবণতা: এটি জটিল দেখাচ্ছে এবং আপনি তাৎক্ষণিকভাবে এর অর্থ কী তা চিনতে পারবেন না।

আমি আপনাকে এই প্রবণতার বিরুদ্ধে লড়াই করার জন্য উৎসাহিত করছি। এই নাম, কমান্ড এবং প্রতীকগুলি আমার কাছে ততটাই অপরিচিত যতটা আপনার কাছে। এই অধ্যায়টি এই জিনিসগুলির অর্থ কী এবং কীভাবে সেগুলি ব্যবহার করতে হয় তা বের করার প্রক্রিয়া সম্পর্কে। আপনি যদি কোডটি পড়ার চেষ্টা করেন তবে আপনি এই অধ্যায় থেকে আরও অনেক কিছু শিখতে পারবেন।

এগিয়ে যান!

**রুবি আপগ্রেড করা**

আমার কাছে ইতিমধ্যেই একটি কম্পিউটার আছে, যা একটি শুরু: এটি ছাড়া আপনি প্রোগ্রামিং করতে পারবেন না।

বর্তমানে, আমি ম্যাক ওএস এক্স ১০.৬ অপারেটিং সিস্টেম চালিত একটি অ্যাপল ম্যাকবুক এয়ার ব্যবহার করছি। একটি দ্রুত অনুসন্ধানে দেখা যাচ্ছে যে অপারেটিং সিস্টেমটিতে রুবি সংস্করণ ১.৮.৭ প্রিইনস্টল করা আছে, যা ভালো খবর: তাত্ত্বিকভাবে, আমি এখনই আমার নিজের কম্পিউটারে রুবি প্রোগ্রাম চালানো শুরু করতে পারি।

সমস্যা হল রুবি ১.৮.৭ রুবি-এর সর্বশেষ সংস্করণ নয়। আমি যখন জেকিল ইনস্টল করার চেষ্টা করি, তখন সিস্টেম আমাকে বলে যে প্রোগ্রামের কমপক্ষে ১.৯.১ সংস্করণ প্রয়োজন, যার মানে আমাকে আপগ্রেড করার উপায় বের করতে হবে। আবার গুগলে ফিরে যাই।

কিছু মৌলিক অনুসন্ধানে দুটি প্রোগ্রাম পাওয়া গেছে যা রুবি ইনস্টলেশনগুলি পরিচালনা করা সহজ করার জন্য ডিজাইন করা হয়েছে: আরবেনভ এবং রুবি-বিল্ড। উভয় প্রোগ্রামই ৩৭সিগন্যালসের রুবি ডেভেলপার স্যাম স্টিফেনসন দ্বারা রক্ষণাবেক্ষণ করা হয়। একসাথে, এই প্রোগ্রামগুলি আপনাকে রুবি-এর নতুন সংস্করণ ইনস্টল করতে এবং আপনার কম্পিউটারকে রুবি-এর কোন সংস্করণ ব্যবহার করতে হবে তা জানাতে সাহায্য করে।

আরবেনভ ডকুমেন্টেশন পৃষ্ঠায় একটি টিউটোরিয়াল রয়েছে যা দেখায় কীভাবে আপনার মেশিনে প্রোগ্রামগুলি ইনস্টল করতে হয়। ইনস্টলেশন কমান্ডগুলি দেখতে এইরকম:

```bash
$ cd ~
$ git clone git://github.com/sstephenson/ruby-build.git
$ cd ruby-build
$ sudo ./install.sh
$ cd ..
$ git clone git://github.com/sstephenson/rbenv.git .rbenv
$ mkdir -p ~/.rbenv/plugins
$ cd ~/.rbenv/plugins
$ git clone git://github.com/sstephenson/ruby-build.git
$ echo ‘export PATH="$HOME/.rbenv/bin:$PATH"’ >> ~/.bashprofile
$ echo ‘eval "$(rbenv init -)"’ >> ~/.bashprofile
$ exec $SHELL
$ rbenv install 1.9.3-p125
$ rbenv rehash
$ rbenv global 1.9.3-p125
```

এটি ভীতিজনক দেখাচ্ছে, তবে এটি কেবল কমান্ডের একটি তালিকা। আসুন এটি ভেঙে ফেলি।

এই কমান্ডগুলি টার্মিনাল নামক একটি প্রোগ্রামে প্রবেশ করানো হয়, যা অ্যাপল কম্পিউটারগুলিতে প্রিইনস্টল করা থাকে। আপনি যদি কখনও সিনেমায় হ্যাকারদের দ্রুত টাইপ করতে দেখেন যাদের কম্পিউটার দীর্ঘ লাইনের টেক্সট দেখাচ্ছে, তবে সেই কম্পিউটারগুলি একটি টার্মিনাল প্রোগ্রাম চালাচ্ছে।

আমি টার্মিনাল খুলি এবং প্রথম কমান্ডটি প্রবেশ করাই:

```bash
$ cd ~
```

এই কমান্ডটি বোঝা সহজ। $ হল টার্মিনাল যখন নতুন কমান্ডের জন্য প্রস্তুত থাকে তখন প্রদর্শন করে, তাই এটি ইতিমধ্যেই সেখানে থাকে। cd হল "চেঞ্জ ডিরেক্টরি"-এর সংক্ষিপ্ত রূপ, যা ফোল্ডারের আরেকটি শব্দ। একটি দ্রুত অনুসন্ধানে আমি জানতে পারি ~ হল "ব্যবহারকারীর হোম ফোল্ডার"-এর সংক্ষিপ্ত রূপ, আমার কম্পিউটারের সেই ফোল্ডার যেখানে আমার ব্যবহারকারীর প্রোফাইল সংরক্ষিত থাকে।

আমি কমান্ডটি টাইপ করি এবং এন্টার কী চাপি। এখন, টার্মিনাল এটি প্রদর্শন করে:

```bash
joshkaufman $
```

এটি ভালো খবর: আমি আমার হোম ডিরেক্টরিতে আছি। এ পর্যন্ত সব ঠিক আছে। আমি দ্বিতীয় কমান্ডটি টাইপ করি:

```bash
$ git clone git://github.com/sstephenson/ruby-build.git
```

কম্পিউটার ফেরত দেয়:

```
git: command not found
```

মনে হচ্ছে আমার মেশিনে git প্রোগ্রামটি ইনস্টল করা নেই। আমাকে এটি কীভাবে ইনস্টল করতে হয় তা বের করতে হবে।

**"Git" কী?**

ম্যাক ওএস এক্স-এ git কীভাবে ইনস্টল করতে হয় তার নির্দেশাবলী অনুসন্ধান করার পরে, আমি হেরোকু টুলবেল্ট খুঁজে পাই। হেরোকু একটি ওয়েব অ্যাপ্লিকেশন সার্ভার হোস্টিং কোম্পানি, তাই ডেভেলপারদের ওয়েব অ্যাপ্লিকেশন তৈরি করা সহজ করার জন্য তাদের একটি নিহিত স্বার্থ রয়েছে।

হেরোকু টুলবেল্ট একটি প্রোগ্রাম যা কিছু সাধারণ সফ্টওয়্যার ডেভেলপমেন্ট সরঞ্জাম ইনস্টল করে যা প্রোগ্রামারদের হেরোকুতে অ্যাপ্লিকেশন ডেভেলপ করার জন্য প্রয়োজন। git সেই প্রোগ্রামগুলির মধ্যে একটি।

আমি ইনস্টলার প্যাকেজটি ডাউনলোড করি, এটি চালাই এবং সবকিছু সঠিকভাবে সেট আপ করা হয়েছে তার একটি নিশ্চিতকরণ পাই। আবার কমান্ডটি চেষ্টা করার সময়:

```bash
$ git clone git://github.com/sstephenson/ruby-build.git
```

আমি এই আউটপুটটি পাই:

```
Cloning into ruby-build . .
.
remote: Counting objects: 1004, done.
remote: Compressing objects: 100% (453/453), done.
remote: Total 1004 (delta 490), reused 937 (delta 431)
Receiving objects: 100% (1004/1004), 108.77 KiB, done.
Resolving deltas: 100% (490/490), done.
```

সাফল্য! "Done" একটি ভালো লক্ষণ এবং আমি কোনও ত্রুটি বার্তা পাইনি। এগিয়ে যান।

আমি বাকি কমান্ডগুলি চালিয়ে যাই। ইনস্টলেশন টিউটোরিয়ালের তথ্যের উপর ভিত্তি করে, আমি যা করছি তা হল প্রয়োজনীয় ফাইলগুলি ডাউনলোড করা, echo নামক একটি কমান্ড ব্যবহার করে স্বয়ংক্রিয়ভাবে আমার কম্পিউটারের কনফিগারেশন ফাইলগুলিতে কিছু টেক্সট যোগ করা, তারপর পরিবর্তনগুলি সংরক্ষণ করার জন্য আমার কম্পিউটারে SHELL নামক একটি প্রোগ্রাম পুনরায় চালু করা। SHELL রিবুট হওয়ার পরে, rbenv এবং ruby-build ইনস্টল করা হয়। ইয়াহু!

এখন রুবি-এর সর্বশেষ সংস্করণ ইনস্টল করার সময়:

```bash
$ rbenv install 1.9.3-p125
```

প্রোগ্রামটি স্বয়ংক্রিয়ভাবে রুবি সোর্স কোড ডাউনলোড করে এবং এটি তৈরি করে, প্রক্রিয়াটিতে টার্মিনাল প্রোগ্রামে প্রচুর পরিমাণে স্ক্রোলিং তথ্য বের করে। (এখন আমি নিজেকে একজন সত্যিকারের হলিউড প্রোগ্রামারের মতো মনে করছি।)

```bash
$ rbenv rehash
```

এই কমান্ডটি, ডকুমেন্টেশন থেকে, কম্পিউটারকে চিনতে সাহায্য করে যে রুবি-এর একটি নতুন সংস্করণ ইনস্টল করা হয়েছে।

```bash
$ rbenv global 1.9.3-p125
```

এই কমান্ডটি এই কম্পিউটারে রুবি-এর ডিফল্ট সংস্করণ হিসাবে ১.৯.৩-পি১২৫ সংস্করণ সেট করে। টিউটোরিয়াল আমাকে আমার কম্পিউটার নতুন সংস্করণ ব্যবহার করছে কিনা তা নিশ্চিত করার জন্য এই কমান্ডটি চালানোর জন্য বলে:

```bash
$ ruby -v
```

আমি যা পাই তা এখানে দেওয়া হল:

```
ruby 1.9.3p125 (2012-02-16 revision 34643) [x86_64-darwin11.3.0]
```

সাফল্য! টিউটোরিয়ালের উপর ভিত্তি করে এটাই বলার কথা।

ডকুমেন্টেশন অনুসারে, আমি যদি এই কম্পিউটারে রুবি-এর একটি নতুন সংস্করণ ইনস্টল করতে চাই, তবে আমাকে যা করতে হবে তা হল আবার rbenv install, rbenv rehash এবং rbenv global চালানো। যথেষ্ট সহজ।

প্রথমদিকে কমান্ডগুলি ভীতিজনক দেখালেও, সেগুলি আসলে বেশ সরল। যা আবোলতাবোল মনে হচ্ছে তা কেবল সংক্ষিপ্ত রূপ। একবার আপনি জেনে গেলে সংক্ষিপ্ত রূপগুলি কীসের জন্য দাঁড়িয়েছে, কমান্ডগুলি নিজেরাই বোঝা সহজ।

মনে রাখবেন, কেউ এই জিনিসগুলি জেনে জন্মায় না। বেশিরভাগ সময়, আপনাকে যা করতে হবে তা হল কয়েক মিনিট ডকুমেন্টেশন পড়া, তারপর এটি আপনাকে যা বলে তা চেষ্টা করা।
**রুবি লাইব্রেরি (জেম) ইনস্টল করা**

রুবি-এর সর্বশেষ সংস্করণ ইনস্টল করার পরে, সিনাত্রা সহ আমার প্রয়োজনীয় লাইব্রেরিগুলি কীভাবে ইনস্টল করতে হয় তা বের করার সময় এসেছে।

রুবি লাইব্রেরিগুলিকে জেম বলা হয় এবং দেখা যাচ্ছে সেগুলি ইনস্টল করা খুব সহজ। সিনাত্রা জেম ইনস্টল করার কমান্ডটি এখানে দেওয়া হল:

```bash
$ gem install sinatra
```

সিনাত্রা আপডেট করার কমান্ডটি এখানে দেওয়া হল:

```bash
$ gem update sinatra
```

এর চেয়ে সহজ আর কিছু হতে পারে না!

তবে, আমি খুব বেশি লাইব্রেরি ইনস্টল করার আগে, আমি নিশ্চিত করতে চাই যে জেম প্রোগ্রামটি আপ-টু-ডেট আছে। যেহেতু আমার কম্পিউটারটি রুবি-এর একটি পুরানো সংস্করণ সহ পাঠানো হয়েছিল, তাই সম্পর্কিত সফ্টওয়্যারটিরও একটি আপডেটের প্রয়োজন হবে বলে মনে হচ্ছে।

কিছু অনুসন্ধানের পরে, আমি রুবি জেম প্রোগ্রামটি আপডেট করার কমান্ডটি খুঁজে পাই:

```bash
$ gem update --system
```

যথেষ্ট সহজ।

আমি যখন `gem install` কমান্ডটি চালাই, তখন আমি লক্ষ্য করি যে কমান্ডটি র্যাক, র্যাক-প্রটেকশন এবং টিল্টের মতো অতিরিক্ত জেমগুলিও ইনস্টল করে। এই অতিরিক্ত লাইব্রেরিগুলিকে নির্ভরতা বলা হয়। সিনাত্রা চালানোর জন্য তাদের উপর নির্ভর করে, তাই `gem install` কমান্ডটি স্বয়ংক্রিয়ভাবে সেগুলি ইনস্টল করে।

**বই ধরা**

এখন যেহেতু আমি রুবি অ্যাপ্লিকেশন চালানোর জন্য প্রস্তুত, তাই আমি Stack Overflow-তে অত্যন্ত সুপারিশকৃত দুটি সাধারণ রুবি রেফারেন্স বই সংগ্রহ করার সিদ্ধান্ত নিয়েছি: ডেভিড এ. ব্ল্যাকের *The Well-Grounded Rubyist* (2009) এবং রুস ওলসেনের *Eloquent Ruby* (2011)। উভয় বই-ই প্রাথমিক ভূমিকা হিসাবে ডিজাইন করা হয়েছে যা পাঠককে সাধারণ রুবি ধারণা এবং কৌশলগুলির পাশাপাশি মৌলিক রেফারেন্স টেক্সটের সাথে পরিচয় করিয়ে দেবে।

আমি অ্যালান হ্যারিস এবং কনস্ট্যান্টিন হাসের *Sinatra: Up and Running* (2011)-ও কিনেছি। এই বইটি সিনাত্রা ফ্রেমওয়ার্কের একটি প্রাথমিক ভূমিকা হিসাবে ডিজাইন করা হয়েছে। যদিও সিনাত্রা অনলাইনে খুব ভালোভাবে ডকুমেন্ট করা আছে, বইটিতে প্রচুর উদাহরণ রয়েছে, যা সাধারণ কাজের জন্য সিনাত্রা কীভাবে ব্যবহার করতে হয় তা বের করা সহজ করে তুলবে।

বইয়ের জন্য ব্রাউজ করার সময়, আমি বেশ কয়েকটি রেফারেন্স ওয়েবসাইটও খুঁজে পেয়েছি যা মৌলিক রুবি সিনট্যাক্স কভার করে:

* দ্য অফিশিয়াল বিগিনার্স গাইড টু রুবি
* দ্য রুবি রিফ্রেশার
* রুবি সিকিউরিটি রিভিউয়ার্স গাইড

শুরু করার জন্য এটি প্রচুর রেফারেন্স উপাদান, তাই আমি এ পর্যন্ত সংগ্রহ করা সবকিছু দ্রুত দেখার জন্য নব্বই মিনিট আলাদা করে রেখেছি।

আমি প্রতিটি বই নিয়ে বসেছিলাম এবং বিষয়বস্তুর সারণী এবং সূচকের একটি দ্রুত স্ক্যান করেছিলাম, গুরুত্বপূর্ণ মনে হওয়া শব্দ এবং ধারণাগুলি নোট করেছিলাম। আমি বারবার আসা ধারণাগুলি, সেইসাথে প্রবর্তনের ক্রমও ধরে রেখেছিলাম। আমি শিরোনাম এবং সাইডবারগুলি পড়েছিলাম। বইগুলি শেষ করার পরে, আমি ওয়েবসাইটগুলির সাথে একই কাজ করেছি।

আমি যা শিখেছি তা এখানে দেওয়া হল। ভেরিয়েবল, শর্তাধীন বিবৃতি, ব্যতিক্রম এবং প্রোগ্রামিংয়ের অন্যান্য মৌলিক বিষয়গুলি ছাড়াও, রুবি দুটি মূল ধারণার উপর নির্মিত: বস্তু এবং পদ্ধতি।

বস্তু হল প্রোগ্রামিং জগতের বিশেষ্য: এগুলি এমন জিনিস যা আমরা কিছু করতে পারি (বা যার সাথে)। ধরুন আমি রুবিতে `firstname` নামক একটি নতুন ভেরিয়েবল তৈরি করতে চাই এবং আমি চাই এটিতে আমার নাম থাকুক। রুবিতে, সেই কমান্ডটি এইরকম দেখাচ্ছে:

```ruby
firstname = “Josh”
```

যথেষ্ট সহজ। উদ্ধৃতি চিহ্নের মধ্যে "Josh" রেখে, আমি রুবিকে বলছি যে `firstname` একটি স্ট্রিং: আলফানিউমেরিক অক্ষরের একটি ক্রম। এটি `firstname`-কে "string" ক্লাসের একটি বস্তুতে পরিণত করে। (একটি ক্লাস হল কেবল নির্দিষ্ট বৈশিষ্ট্যযুক্ত একটি নির্দিষ্ট ধরণের বস্তু।)

স্ট্রিংগুলি বস্তুর একমাত্র শ্রেণী নয়। এখানে একটি বস্তু রয়েছে যা পূর্ণসংখ্যা শ্রেণীতে রয়েছে:

```ruby
million = 1000000
```

যদি বস্তুগুলি প্রোগ্রামিংয়ে বিশেষ্য হয়, তবে পদ্ধতিগুলি হল ক্রিয়া: এগুলি এমন জিনিস যা আমরা কোনও বস্তুর সাথে (বা যার সাথে) করতে পারি।

ধরুন আমার কাছে দুটি স্ট্রিং অবজেক্ট রয়েছে যাতে আমার প্রথম এবং শেষ নাম রয়েছে:

```ruby
firstname = “Josh”
lastname = “Kaufman”
```

আমি এই স্ট্রিংগুলিকে সংযুক্ত করতে একটি প্লাস চিহ্ন (+) ব্যবহার করতে পারি, যা "তাদের একসাথে রাখা"-এর একটি অভিনব শব্দ:

```ruby
fullname = firstname + lastname
```

ছোট পরীক্ষা: `fullname`-এ কী রয়েছে? আপনি যদি "Josh Kaufman" অনুমান করে থাকেন তবে আপনি ভুল।

মনে রাখবেন, কম্পিউটার কেবল তাই করবে যা আপনি তাকে করতে বলবেন। আমরা কম্পিউটারকে "Josh" এবং "Kaufman"-এর মধ্যে একটি স্পেস যোগ করতে বলিনি, তাই এটি করেনি। `fullname` সমান "JoshKaufman"।

যদি আমরা এই ছোট বাগটি সংশোধন করতে চাই, তবে আমাদের একটি স্পেস যোগ করার জন্য কোডটি পরিবর্তন করতে হবে:

```ruby
fullname = firstname + “ “ + lastname
```

+ একটি পদ্ধতি, এবং পদ্ধতিটি কীভাবে কাজ করে তা নির্ভর করে আমরা কোন বস্তুগুলির উপর এটি ব্যবহার করি তার উপর। যদি আমরা স্ট্রিংগুলির পরিবর্তে পূর্ণসংখ্যার উপর এটি ব্যবহার করি তবে এটি সংযোজনের পরিবর্তে যোগ করে:

```ruby
sum = million + million
```

`sum` কত? "2000000"

রুবি-এর বিল্ট-ইন পদ্ধতিগুলি আপনাকে এখনই অনেক দারুণ জিনিস করতে সাহায্য করতে পারে। ধরুন আমি দেখতে চাই আমার পুরো নামটি উল্টো করে কেমন দেখায়। হাতে বের করার বা অক্ষরগুলি উল্টানোর জন্য আমার নিজস্ব ছোট প্রোগ্রাম লেখার পরিবর্তে, আমি প্রতিটি স্ট্রিং অবজেক্টের জন্য উপলব্ধ `reverse` পদ্ধতিটি ব্যবহার করতে পারি:

```ruby
fullname.reverse
```

এখানে আউটপুট: `namfuaKhsoJ`

আমি একবারে একাধিক পদ্ধতিও ব্যবহার করতে পারি। যদি আমি একই সাথে আমার নামের অক্ষরগুলি উল্টাতে এবং সমস্ত অক্ষরকে ছোট অক্ষরে রূপান্তর করতে চাই তবে আমি এটি চালাতে পারি:

```ruby
fullname.reverse.downcase
```

আউটপুট: `namfuakhsoj`। পরিপাটি!

রুবিতে কোড শিখার একটি বড় অংশ বস্তু, শ্রেণী এবং পদ্ধতি ব্যবহার, তৈরি এবং ম্যানিপুলেট করার সাথে জড়িত বলে মনে হয়। ভাষাটিতে এগুলির অনেকগুলি বিল্ট-ইন রয়েছে এবং রুবি আপনাকে বস্তু, শ্রেণী এবং পদ্ধতিগুলিকে আপনি যেভাবে চান সেভাবে তৈরি, পরিবর্তন বা অপসারণ করার অনুমতি দেয়, যা ভাষাকে প্রচুর শক্তি এবং নমনীয়তা দেয়।

রুবি-এর অফিসিয়াল ডকুমেন্টেশনে ব্যবহারের জন্য উপলব্ধ সমস্ত বস্তু এবং পদ্ধতির প্রামাণিক তালিকা রয়েছে। একটি দ্রুত নজরে এটি অপ্রতিরোধ্য, তবে এটি উপলব্ধি করা সহায়ক যে আপনাকে সেগুলি সব ব্যবহার করতে হবে না। বিপরীতে, আপাতত সেগুলির বেশিরভাগ উপেক্ষা করা নিরাপদ। সেগুলি বিকল্প, যখন আপনার প্রয়োজন তখন ব্যবহারের জন্য প্রস্তুত।

ডকুমেন্টেশন আরেকটি উদ্দেশ্য পরিবেশন করে: যখন আপনি এমন কিছু করার চেষ্টা করেন যা রুবি বুঝতে পারে না, তখন ফলস্বরূপ ত্রুটি বার্তাটি আপনাকে বলবে প্রোগ্রামটি কোথায় ভেঙেছে।

ধরুন আমরা এইরকম একটি প্রোগ্রাম চালানোর চেষ্টা করি:

```ruby
animal = “Zebra”
number = 7
puts animal + number
```

`puts` কমান্ডটি প্রিন্ট বলার আরেকটি উপায়। আমরা কেবল প্রোগ্রামটি `animal + number`-এর অর্থ কী মনে করে তা প্রদর্শন করতে চাই।

আমি যখন প্রোগ্রামটি চালানোর চেষ্টা করি তখন আমি যা পাই তা এখানে দেওয়া হল:

```
TypeError: can’t convert Fixnum into String from program.rb:3:in ‘+’
```

কম্পিউটারের ভাষা ছাড়া: আপনি এমনভাবে কোনও শব্দে সংখ্যা যোগ করতে পাটিগণিত ব্যবহার করতে পারবেন না যা অর্থবোধক হয়, তাই কম্পিউটার একটি ত্রুটি প্রদর্শন করে। এটি শূন্য দিয়ে ভাগ করার চেষ্টা করার মতো: আপনি এটি করতে পারবেন না, তাই প্রোগ্রামটি বন্ধ হয়ে যায়।

প্রোগ্রামটি ঠিক করার জন্য, আমাদের হয় সংখ্যাটিকে একটি স্ট্রিংয়ে রূপান্তর করতে হবে যাতে + পদ্ধতিটি পাটিগণিত ব্যবহার করার চেষ্টা করার পরিবর্তে দুটি ভেরিয়েবলকে সংযুক্ত করে, অথবা অন্য কিছু করার জন্য প্রোগ্রামটি সংশোধন করতে হবে।

এখানে একটি সংশোধিত প্রোগ্রাম:

```ruby
animal = “Zebra”
number = 7.to_s
puts animal + number
```

আমরা যখন প্রোগ্রামটি চালাই, তখন আমরা আউটপুট পাই "Zebra7"। বিল্ট-ইন `.to_s` পদ্ধতিটি সংখ্যা ৭ কে একটি স্ট্রিংয়ে রূপান্তর করে, তাই রুবি সংযোজন ব্যবহার করতে পারে।

আমরা সম্পূর্ণ ভিন্ন কিছুও করতে পারি, যেমন:

```ruby
animal = “Zebra”
number = 7
number.times { puts “#{animal}” }
```

এখানে আউটপুট:

```
Zebra
Zebra
Zebra
Zebra
Zebra
Zebra
Zebra
```

আমরা কেবল একটি মৌলিক শর্তাধীন লুপ ব্যবহার করেছি, যা রুবিতে বিল্ট-ইন: `number.times`-এর অর্থ হল "এটি X বার করুন, যেখানে X `number` ভেরিয়েবলের মানের সমান।" যদি আমরা `animal` বা `number`-এর মান পরিবর্তন করি তবে আমরা আউটপুট পরিবর্তন করব। (হ্যাঁ, আপনি চাইলে এই প্রোগ্রামটি " wombat " এক বিলিয়ন বার প্রিন্ট করার জন্য সংশোধন করতে পারেন।)

**মন্তব্যকরণ এবং ডিবাগিং**

পড়ার সময়, আমি রুবিতে আরেকটি মৌলিক বৈশিষ্ট্যও শিখেছি: মন্তব্যকরণ। আপনি যখনই # (প্রায়শই "পাউন্ড সাইন" বা, কম ঘন ঘন, "অক্টোথর্প" বলা হয়) দিয়ে কোনও প্রোগ্রামের লাইন শুরু করেন, রুবি সেই লাইনটিকে একটি মন্তব্য হিসাবে ব্যাখ্যা করে এবং তা এড়িয়ে যায়।

কোনও প্রোগ্রামে মন্তব্য যোগ করা এটিকে অনুসরণ করা অনেক সহজ করে তোলে, কারণ আপনি সাধারণ ভাষায় আপনি কী করার চেষ্টা করছেন তা ব্যাখ্যা করতে পারেন। আমার "অ্যানিমাল প্রিন্ট" প্রোগ্রামে মন্তব্যগুলি কেমন দেখাবে তা এখানে দেওয়া হল:

```ruby
# Assign variables
animal = “Wombat”
number = 1000000000
# Print loop
number.times { puts “#{animal}” }
```

মন্তব্যকরণ একটি মৌলিক সমস্যা সমাধানের কৌশলও: সমস্যা বা বাগগুলি আলাদা করার জন্য আপনি একবারে কয়েক লাইন কোড মন্তব্য করে দিতে পারেন। ভালোভাবে স্থাপন করা `print` বা `puts` বিবৃতির সাথে মিলিত হয়ে, সবকিছু প্রত্যাশা অনুযায়ী কাজ করছে কিনা তা নিশ্চিত করার জন্য আপনি ধাপে ধাপে কোনও প্রোগ্রামের নির্বাহ অনুসরণ করতে পারেন।

মোট আট ঘন্টা গবেষণা এবং ইনস্টলেশনের পরে, আমি এখন রুবি-এর সর্বশেষ সংস্করণ চালাচ্ছি, আমার প্রয়োজনীয় যেকোনো লাইব্রেরি ইনস্টল করতে পারি এবং রুবি প্রোগ্রামগুলি কীভাবে কাজ করে সে সম্পর্কে আমার একটি মৌলিক ধারণা রয়েছে।

এটি উল্লেখ করা গুরুত্বপূর্ণ যে আমি এখনও পর্যন্ত উল্লেখযোগ্য কিছু প্রোগ্রাম করিনি। এ পর্যন্ত সময় গবেষণা, রুবি ইনস্টল করা এবং রুবি প্রোগ্রাম লেখা কেমন লাগে তা অনুভব করার জন্য ব্যয় করা হয়েছে।

আসুন আরও জটিল প্রোগ্রামগুলি অন্বেষণ করি।

**আইআরবি দিয়ে পরীক্ষা করা**

আমার Stack Overflow গবেষণায়, আমি রব সোবার্স এবং জেড শ-এর *Learn Ruby the Hard Way* নামক একটি অনলাইন রুবি টিউটোরিয়াল খুঁজে পেয়েছি। টিউটোরিয়ালটি আপনাকে সহজ রুবি প্রোগ্রামগুলির উদাহরণ দিয়ে এবং নির্দিষ্ট ফলাফল তৈরি করার জন্য সেগুলি সংশোধন ও চালানোর জন্য জিজ্ঞাসা করে রুবি কীভাবে কাজ করে তা ব্যাখ্যা করে। যদি আপনি সঠিক ফলাফল না পান, তবে আপনার কাজটি কাঙ্ক্ষিত ফলাফল না পাওয়া পর্যন্ত প্রোগ্রামটি সংশোধন করে পরীক্ষা করা।

এই "কোড, পরীক্ষা, চালান, ডিবাগ" পদ্ধতিটি দ্রুত প্রতিক্রিয়া লুপের একটি ভালো উদাহরণ। আপনি যখন কোনও প্রোগ্রাম চালান, কম্পিউটার আপনাকে মিলি সেকেন্ডের মধ্যে জানাবে এটি কাজ করেছে কিনা। আপনার কোডে যদি কোনও বাগ থাকে তবে আপনি তা পরিবর্তন করতে এবং প্রোগ্রামটি আবার চালাতে পারেন, এক মিনিটের মধ্যে বেশ কয়েকটি ভিন্নতা পরীক্ষা করতে পারেন।

*Learn Ruby the Hard Way*-এর প্রথম অধ্যায়গুলিতে রুবি সেট আপ করা, একটি মৌলিক টেক্সট এডিটিং প্রোগ্রাম ইনস্টল করা এবং আইআরবি (IRB) কীভাবে ব্যবহার করতে হয় তা শেখা জড়িত: একটি প্রোগ্রাম যা আপনার নিজের কম্পিউটারে রুবি প্রোগ্রাম চালায়।

এটি কীভাবে কাজ করে তা এখানে দেওয়া হল। আপনি একটি টেক্সট এডিটরে আপনার প্রোগ্রাম টাইপ করেন এবং একটি ফাইলে সেভ করেন। (ধরে নিই ফাইলের নাম program.rb।) আপনি যখন প্রোগ্রামটি চালানোর জন্য প্রস্তুত হন, তখন আপনি টার্মিনালে এটি টাইপ করেন:

```bash
$ irb program.rb
```

IRB প্রোগ্রামটি চালাবে এবং আপনাকে ফলাফল দেবে। এটি সেই ফলাফলে পৌঁছানোর জন্য কম্পিউটার যে পদক্ষেপগুলি নিয়েছে তাও আপনাকে দেখাবে, যা ডিবাগিংয়ের জন্য দরকারী। প্রোগ্রামটি সঠিক না হলে, IRB একটি বিস্তারিত ত্রুটি বার্তা বের করবে।

*Learn Ruby the Hard Way* ভেরিয়েবল নির্ধারণ, মৌলিক পাটিগণিত করা, স্ট্রিং ম্যানিপুলেট করা এবং মৌলিক শর্তাধীন বিবৃতি সেট আপ করার মাধ্যমে শুরু হয়, যা আমি এইমাত্র উল্লেখ করা উদাহরণগুলির মতোই। এটি মৌলিক বিষয়গুলি শেখার জন্য একটি খুব কাঠামোগত, যৌক্তিক পদ্ধতি।

আমার আসল পরিকল্পনা ছিল *Eloquent Ruby* এবং *The Well-Grounded Rubyist* পড়া, তারপর আমার প্রথম "আসল" প্রোগ্রাম লেখার চেষ্টা করার আগে *Learn Ruby the Hard Way*-এর সমস্ত অনুশীলন সম্পন্ন করা। তবে, প্রায় ১০ নম্বর পাঠের দিকে, আমি একটি গুরুত্বপূর্ণ জিনিস লক্ষ্য করেছি: আমি অস্থির হয়ে উঠছি এবং আগ্রহ হারাচ্ছি।

এখানে সমস্যার মূল: আমি অন্য কারও তৈরি করা প্রোগ্রামগুলি অনুলিপি করছি এবং অন্য কারও সংজ্ঞায়িত সমস্যাগুলি সমাধান করছি। এই প্রোগ্রামগুলি কখনও কখনও আকর্ষণীয়, তবে সেগুলি আমার সমস্যা সমাধান করে না। প্রোগ্রামিং একটি দরকারী দক্ষতার পরিবর্তে একটি একাডেমিক অনুশীলনের মতো মনে হতে শুরু করেছে। আমার গবেষণা মোড থেকে বাস্তবায়ন মোডে যেতে হবে।

প্রোগ্রামিং শুরু করার আগে আমার আবিষ্কৃত সমস্ত বই, কোর্স, টিউটোরিয়াল এবং অন্যান্য সংস্থান পড়ার দরকার নেই। আমার অবিলম্বে আসল প্রোগ্রাম লেখা শুরু করতে হবে, তারপর যদি এবং যখন আমি আটকে যাই তখন আমার সংস্থানগুলি উল্লেখ করতে হবে।

এবার হাত নোংরা করার পালা...

**অ্যাপ্লিকেশন #১: সিনাত্রাতে একটি স্ট্যাটিক ওয়েবসাইট**

আমার প্রথম ওয়েব অ্যাপ্লিকেশনটির জন্য আমার ইতিমধ্যেই একটি ধারণা রয়েছে: একটি সিনাত্রা অ্যাপ্লিকেশন যা একটি বেসিক HTML ওয়েবসাইট পরিবেশন করে। এই অ্যাপ্লিকেশনটির জন্য আমার লক্ষ্য কর্মক্ষমতার স্তর এখানে দেওয়া হল:

১. একটি মৌলিক কার্যকরী সিনাত্রা অ্যাপ্লিকেশন তৈরি করুন যা শেষ ব্যবহারকারীকে (একজন পাঠককে) একটি সাধারণ ওয়েবসাইট সরবরাহ করতে সক্ষম।

২. এটি কাজ করছে কিনা তা নিশ্চিত করার জন্য আমার কম্পিউটারে অ্যাপ্লিকেশনটি পরীক্ষা করুন।

৩. হেরোকুতে সেই অ্যাপ্লিকেশনটি প্রোডাকশনে স্থাপন করুন, এটিকে "লাইভ" করুন যাতে আসল পাঠকরা এটি ব্যবহার করতে পারে।

এইটুকুই। কোনও অভিনব বৈশিষ্ট্য নয়, কেবল একটি খুব সাধারণ সিনাত্রা প্রোগ্রাম একটি পাবলিক সার্ভারে চলছে।

তাহলে আমার কোথায় শুরু করা উচিত? আসুন আমার অনুশীলন চেকলিস্ট পর্যালোচনা করি:

১. একটি ভালোবাসার যোগ্য প্রকল্প বেছে নিন।
২. একবারে একটি দক্ষতার উপর আপনার শক্তি কেন্দ্রীভূত করুন।
৩. আপনার লক্ষ্য কর্মক্ষমতার স্তর সংজ্ঞায়িত করুন।
৪. দক্ষতাটিকে উপ-দক্ষতায় বিভক্ত করুন।
৫. সমালোচনামূলক সরঞ্জামগুলি পান।
৬. অনুশীলনের বাধাগুলি দূর করুন।
৭. অনুশীলনের জন্য নিবেদিত সময় তৈরি করুন।
৮. দ্রুত প্রতিক্রিয়া লুপ তৈরি করুন।
৯. ছোট ছোট বিস্ফোরণে ঘড়ির দিকে তাকিয়ে অনুশীলন করুন।
১০. পরিমাণ এবং গতির উপর জোর দিন।

আমার একটি একক, ভালোভাবে সংজ্ঞায়িত প্রকল্প রয়েছে। আমি দক্ষতাটিকে বিভক্ত করেছি এবং শেষ হলে এই প্রোগ্রামটি কেমন দেখাবে তা আমি জানি। এটি আমাকে সমালোচনামূলক সরঞ্জামগুলিতে নিয়ে আসে: এই প্রকল্পটি সম্পূর্ণ করার জন্য আমার কি এমন কিছুর প্রয়োজন যা আমার কাছে ইতিমধ্যে নেই?

দেখা যাচ্ছে, হ্যাঁ: আমার এখনও হেরোকু অ্যাকাউন্ট নেই। এটি ঠিক করা সহজ: আমি Heroku.com-এ যাই, Sign Up বোতামে ক্লিক করি, আমার ইমেল ঠিকানা যাচাই করি এবং একটি পাসওয়ার্ড তৈরি করি।

যেহেতু আমি ইতিমধ্যেই হেরোকু টুলবেল্ট ডাউনলোড করেছি (যে প্রোগ্রামটি আমি git ইনস্টল করতে ব্যবহার করেছি), তাই হেরোকু জেম ইতিমধ্যেই আমার কম্পিউটারে রয়েছে, তাই আমি সেখানেও প্রস্তুত।

নির্দেশাবলী অনুসারে, আমার কম্পিউটারকে হেরোকুর সাথে কথা বলার অনুমতি দেওয়ার জন্য আমাকে আরও একটি কাজ করতে হবে: "এসএসএইচ কী" নামক কিছু তৈরি করা, একটি বিশেষ ফাইল যা পাসওয়ার্ড হিসাবে কাজ করে বলে মনে হয়। একবার আমার কাছে একটি কী থাকলে, আমাকে এটি হেরোকুতে আপলোড করার কথা যাতে সিস্টেম আমার কম্পিউটারকে চিনতে পারে এবং অ্যাক্সেস দিতে পারে।

সৌভাগ্যক্রমে, হেরোকুতে এটি কীভাবে করতে হয় তার একটি টিউটোরিয়াল রয়েছে। আমি কী তৈরি করার জন্য এই কমান্ডটি চালাই:

```bash
$ ssh-keygen -t rsa
```

... হেরোকুতে লগ ইন করার জন্য এই কমান্ডটি:

```bash
$ heroku login
```

... এবং আমার হেরোকু অ্যাকাউন্টে কী যোগ করার জন্য এই কমান্ডটি:

```bash
$ heroku keys:add
```

দারুণ: আমি ভিতরে আছি। এখন আমি কীভাবে অ্যাপ্লিকেশন লেখা শুরু করব?

**বেসিক অ্যাপ তৈরি করা**

এবার হেরোকুর ডকুমেন্টেশন ব্রাউজ করার পালা। দারুণ: দুটি গাইড দরকারী মনে হচ্ছে:

* "Getting Started with Ruby on Heroku"
* "Deploying Rack-Based Apps"

এই গাইডগুলির উপর ভিত্তি করে, দেখে মনে হচ্ছে আমার নিম্নলিখিত কাজগুলি করতে হবে:

১. আমার কম্পিউটারে প্রোগ্রাম ফাইল তৈরি করুন।
২. সেগুলিকে একটি "git রিপোজিটরি"-তে যোগ করুন। (সেটা আবার কী...)
৩. সমাপ্ত অ্যাপ্লিকেশনটি হেরোকুতে পাঠানোর জন্য `git push heroku master` কমান্ডটি ব্যবহার করুন।

সৌভাগ্যক্রমে, টিউটোরিয়ালে একটি উদাহরণ অন্তর্ভুক্ত রয়েছে এবং এটি একটি সিনাত্রা অ্যাপ্লিকেশন! এটা আমার ধারণার চেয়ে সহজ হবে...

আমি আমার কম্পিউটারে একটি নতুন ফোল্ডার তৈরি করি। এই ফোল্ডারটিকে "রুট" ফোল্ডার বলা হয় এবং প্রোগ্রামের প্রতিটি ফাইল এখানে সংরক্ষণ করা হবে।

এর পরে, আমি আমার টেক্সট এডিটর (আমি TextMate ব্যবহার করছি) খুলি এবং নির্দেশাবলী অনুসরণ করে তিনটি ফাইল তৈরি করি:

```
application.rb
config.ru
Gemfile
```

প্রোগ্রামের মূল অংশ `application.rb`-তে যাবে। রুবি অ্যাপ্লিকেশনগুলি সর্বদা `.rb` দিয়ে শেষ হয়।

`config.ru` হল সেই জায়গা যেখানে Rack কনফিগারেশন সেটিংস যায়। মনে রাখবেন, সিনাত্রা Rack-এর উপরে নির্মিত, তাই এর একটি পৃথক কনফিগারেশন ফাইল থাকা যুক্তিযুক্ত। "Rackup" ফাইলগুলি `.ru` দিয়ে শেষ হয়।

`Gemfile` হল সেই জায়গা যেখানে প্রোগ্রামটি কোন জেমগুলি ব্যবহার করবে তা নির্দিষ্ট করতে হয়। আপনার প্রোগ্রামের সর্বদা একটি `Gemfile` থাকবে, তাই এটিকে সর্বদা "Gemfile" বলা হয়।

যথেষ্ট সহজ মনে হচ্ছে।

ফাইলগুলি তৈরি করার পরে, হেরোকু ডকুমেন্টেশন সেটআপ পরীক্ষা করার জন্য একটি মৌলিক "Hello, World!" প্রোগ্রাম লেখার পরামর্শ দেয়। `application.rb`-তে যা যায় তা এখানে দেওয়া হল:

```ruby
require ‘sinatra’

get'/' do
  "Hello World!"
end
```

`config.ru`-তে যা যায় তা এখানে দেওয়া হল:

```ruby
require ‘./application.rb’

run Sinatra::Application
```

এবং `Gemfile`-এ যা যায় তা এখানে দেওয়া হল:

```ruby
source ‘[http://rubygems.org](http://rubygems.org)’
gem ‘sinatra’
```

এটি খুব বেশি কোড নয় এবং এটি বোঝা বেশ সহজ।

`Gemfile` সার্ভারকে সিনাত্রা জেম অন্তর্ভুক্ত করতে বলে, যা অ্যাপ্লিকেশনটি চালানোর জন্য প্রয়োজনীয়। জেমটি RubyGems.org থেকে ডাউনলোড করা হবে।

`config.ru` ফাইলটি মূল অ্যাপ্লিকেশন সেট আপ করে, তারপর প্রোগ্রামটি চালায়।

প্রোগ্রামটি চালু হওয়ার পরে, যখন কেউ "/" ভিজিট করবে তখন প্রোগ্রামটি "Hello, World!" প্রদর্শন করবে, যা একটি ওয়েবসাইটের হোম পেজকে বোঝানোর একটি সংক্ষিপ্ত উপায়।

এটা কি সত্যিই এত সহজ হতে পারে?

টিউটোরিয়াল আমাকে বলে যে আরও একটি কাজ করতে হবে: ফাইলগুলিকে একটি git রিপোজিটরিতে (কখনও কখনও সংক্ষেপে "repo" বলা হয়) সংরক্ষণ করা। আমি ঠিক নিশ্চিত নই এর অর্থ কী, তবে আমি জানি git ইতিমধ্যেই ইনস্টল করা আছে এবং তারা কমান্ডগুলি সরবরাহ করে:

```bash
$ git init .
$ git add -A
$ git commit -m “Initial Commit”
```

প্রথম কমান্ডটি বর্তমান রুট ফোল্ডারে একটি নতুন git repo তৈরি করে।

`add -A` কমান্ডটি ফোল্ডারের সমস্ত ফাইলকে repo-তে যোগ করে। `commit -m` কমান্ডটি প্রোগ্রামারের একটি বার্তা সহ ফাইলগুলিকে repo-তে কমিট করে, যা কী কমিট করা হচ্ছে তার বিশদ বিবরণ দেয়। ("add" এবং "commit"-এর মধ্যে পার্থক্য আমি এখনও স্পষ্ট নই, তাই আমি এটি পরে অন্বেষণ করার জন্য একটি নোট রাখছি।)

এই কমান্ডগুলি প্রবেশ করার পরে, কম্পিউটার আমাকে বলে:

```
[master (root-commit) 8ed1099] Initial commit
 3 files changed, 9 insertions(+), 0 deletions(-)
 create mode 100644 Gemfile
 create mode 100644 application.rb
 create mode 100644 config.ru
```

দেখে মনে হচ্ছে এটা কাজ করেছে!

আরও একটি কাজ বাকি: হেরোকুতে একটি নতুন খালি সার্ভার তৈরি করা, তারপর সেই সার্ভারে আমার প্রোগ্রাম "পুশ" করা।

সার্ভার তৈরি করার জন্য আমি এই কমান্ডটি চালাই:

```bash
$ heroku create
```

এবং আমি এই প্রতিক্রিয়া পাই:

```
Creating shielded-springs-2049 . . . done, stack is stack is bamboo-ree-1.8.7
[http://shielded-springs-2049.heroku.com/](http://shielded-springs-2049.heroku.com/) | git@heroku.com:shielded-springs-2049.git
Git remote heroku added
```

সাফল্য! "stack" সার্ভারটি যে সফ্টওয়্যার চালাচ্ছে তার বিশদ বিবরণ দেয় এবং বার্তাটি আমাকে সার্ভারের পাবলিক URL দেয়।

এখানে চূড়ান্ত কমান্ড:

```bash
$ git push heroku master
```

যদি সবকিছু ঠিকঠাক হয়, আমি আনুষ্ঠানিকভাবে হেরোকুতে আমার প্রথম অ্যাপ্লিকেশনটি প্রোডাকশনে পুশ করব।

আমি যা পাই তা এখানে দেওয়া হল:

```
Heroku receiving push
Ruby/Sinatra app detected
Gemfile detected, running Bundler version 1.0.7
Unresolved dependencies detected; Installing . . .
Using --without development:test
! Gemfile.lock will soon be required
! Check Gemfile.lock into git with `git add Gemfile.lock`
! See [http://devcenter.heroku.com/articles/bundler](http://devcenter.heroku.com/articles/bundler)
Fetching source index for [http://rubygems.org/](http://rubygems.org/)
Installing rack (1.4.1)
Installing rack-protection (1.2.0)
Installing tilt (1.3.3)
Installing sinatra (1.3.3)
Using bundler (1.0.7)
Your bundle is complete! It was installed into ./.bundle/gems/
Compiled slug size: 500K
Launching . . . done, v4
[http://shielded-springs-2049.heroku.com](http://shielded-springs-2049.heroku.com) deployed to Heroku
```

এখন, সত্যের মুহূর্ত... আমি একটি ওয়েব ব্রাউজার খুলি, http://shielded-springs-2049.heroku.com-এ নেভিগেট করি এবং আমি যা দেখি তা হল:

"Hello, World!"

বিজয়!

**সতর্কতা, সতর্কতা!**

প্রোগ্রামটি কাজ করেছে, তবে আমি একটি সতর্কীকরণ বার্তাও পেয়েছি। `Gemfile.lock` কী?

হেরোকুর রুবি ডকুমেন্টেশন দেখায় যে সিস্টেমটি হেরোকুতে জেম ইনস্টল করার জন্য বান্ডলার নামক একটি লাইব্রেরি ব্যবহার করে। এটি একটি জেম, তাই আমি এটি স্থানীয়ভাবে চালিয়ে ইনস্টল করতে পারি:

```bash
$ gem install bundler
```

বান্ডলার প্রয়োজনীয় কারণ হেরোকু ডিফল্টরূপে আপনার অ্যাপ্লিকেশনে কোনও জেম ইনস্টল করে না। নিরাপত্তার কারণে, হেরোকু আমাকে আমার মেশিনে থাকা একই স্তরের কম্পিউটার অ্যাক্সেস দেয় না, তাই আমার অ্যাকাউন্টে সরাসরি `gem install sinatra` চালানোর কোনও উপায় নেই।

আমাকে (বা অন্য কোনও ব্যবহারকারীকে) বিপজ্জনক স্তরের সিস্টেম অ্যাক্সেস দেওয়ার পরিবর্তে, হেরোকু Gemfile-এ নির্দিষ্ট জেমগুলি ইনস্টল করতে বান্ডলার ব্যবহার করে। একবার আপনি আপনার অ্যাপ্লিকেশনে কোন জেমগুলি ইনস্টল করতে চান তা সনাক্ত করার পরে, আপনি আপনার কম্পিউটারে এই কমান্ডটি চালান:

```bash
$ bundle install
```

এই কমান্ডটি আপনার প্রোগ্রামে `Gemfile.lock` নামক একটি নতুন ফাইল তৈরি করে। আপনি যখন হেরোকুতে আপনার ফাইলগুলি আপলোড করেন, তখন সিস্টেম `Gemfile` এবং `Gemfile.lock` দেখে, নিরাপত্তার জন্য সেগুলি একই কিনা তা যাচাই করে, জেমগুলি ডাউনলোড করে এবং তারপরে আপনার জন্য সেগুলি ইনস্টল করে।

আমি যখন প্রোগ্রামটি হেরোকুতে পুশ করি তখন আপনি যদি আউটপুটটি দেখেন, আপনি দেখতে পাবেন যে সিস্টেমটি স্বয়ংক্রিয়ভাবে বান্ডলারকে একটি নির্ভরতা হিসাবে ইনস্টল করেছে। একটি ত্রুটি বার্তা প্রদর্শনের পরিবর্তে, হেরোকুর প্রকৌশলীরা প্রোগ্রামটিতে স্বয়ংক্রিয়ভাবে প্রোগ্রামটি ইনস্টল করার এবং ক্র্যাশ হওয়ার পরিবর্তে একটি সতর্কতা প্রদর্শনের জন্য একটি ব্যতিক্রম যুক্ত করেছেন।

সিস্টেমটি এবার কাজ করেছে, তবে ভবিষ্যতে, অ্যাপ্লিকেশনটি পুশ করার আগে আমাকে `Gemfile.lock` git রিপোজিটরিতে যোগ করতে হবে। জেনে রাখা ভালো!

**সিনাত্রার আত্মপ্রকাশ**

এখন যেহেতু আমার সরল অ্যাপ্লিকেশনটি চালু এবং চলছে, আমি অবশেষে সিনাত্রা কীভাবে কাজ করে তা শিখতে শুরু করতে পারি। সিনাত্রার ডকুমেন্টেশন খুব ব্যাপক এবং উদাহরণে পূর্ণ, তাই আমি সেখান থেকেই শুরু করার সিদ্ধান্ত নিয়েছি।

সিনাত্রা অ্যাপ্লিকেশনগুলির মূল অংশটিকে রুট বলা হয়। এই ধারণাটি বোঝার সেরা উপায় হল উদাহরণের মাধ্যমে।

আমাদের মৌলিক সিনাত্রা অ্যাপ্লিকেশনে একটি একক রুট রয়েছে, যা আমাদের ছোট্ট ওয়েবসাইটের "মূল" ধারণ করে। ইন্টারনেট ব্যবহারকারীরা সাধারণত ওয়েবসাইট রুটকে ওয়েবসাইটের হোম পেজ হিসাবে উল্লেখ করে।

আপনি যদি google.com বা yahoo.com ভিজিট করেন, আপনার ওয়েব ব্রাউজার Google বা Yahoo-এর সার্ভারে একটি অনুরোধ পাঠায়। এই অনুরোধটিকে GET অনুরোধ বলা হয় এবং এটি সার্ভারকে ওয়েবসাইটের রুট ডিরেক্টরিতে যা কিছু আছে তা আপনাকে দেখাতে বলে। কম্পিউটার অনুরোধ পাঠানোর জন্য যে প্রোটোকল বা বিন্যাস ব্যবহার করে, তাকে HTTP বলা হয়, যার অর্থ "হাইপারটেক্সট ট্রান্সফার প্রোটোকল"। ওয়েব ঠিকানাগুলির শুরুতে আপনি প্রায়শই যে "http://" দেখেন তার অর্থ এটাই।

GET হল সবচেয়ে সাধারণ ধরণের HTTP অনুরোধ, তবে এটি একমাত্র প্রকার নয়। আরও তিনটি HTTP "ক্রিয়া" রয়েছে:

* POST - সার্ভারে একটি রিসোর্স পাঠানো
* PUT - সার্ভারে একটি রিসোর্স আপডেট করা
* DELETE - সার্ভার থেকে একটি রিসোর্স সরানো

আপনি যদি কখনও কোনও ওয়েবসাইটে কোনও পাবলিক মন্তব্য পোস্ট করে থাকেন, তবে আপনার বুদ্ধিদীপ্ত মন্তব্যগুলি POST কমান্ড ব্যবহার করে সার্ভারে পাঠানো হয়েছিল। আপনি যদি কোনও ভুল করে থাকেন এবং মন্তব্যটি সম্পাদনা করে থাকেন তবে আপনার আপডেট PUT কমান্ডের মাধ্যমে পাঠানো হয়েছিল। আপনি যদি সিদ্ধান্ত নেন যে মন্তব্যটি বোকা এবং এটি সরানোর সিদ্ধান্ত নেন, তবে ব্রাউজার একটি DELETE কমান্ড পাঠিয়েছিল।

GET, POST, PUT এবং DELETE কমান্ড ধারণকারী রুটগুলি সিনাত্রা অ্যাপ্লিকেশনগুলি কীভাবে কাজ করে তার মূল অংশ। আপনি যে প্রতিটি রুট তৈরি করেন তা একটি শর্তাধীন বিবৃতি: "যদি রুট Y-এ একটি GET/POST/PUT/DELETE কমান্ড আসে তবে X করুন।"

সিনাত্রা রুটে ভেরিয়েবলও থাকতে পারে, যাকে প্যারামিটার বলা হয়। সিনাত্রা অ্যাপ্লিকেশনগুলি সাধারণত প্রতিটি রুটে থাকা প্রক্রিয়ার জন্য ইনপুট হিসাবে প্যারামিটার ব্যবহার করে।

আসুন আমাদের সরল সিনাত্রা "Hello, World!" অ্যাপ্লিকেশনটিকে আমাদের ব্যবহারকারীকে নাম ধরে অভিবাদন জানানোর জন্য সংশোধন করি। এখানে একটি রুট দেওয়া হল যা এটি করবে:

```ruby
get ‘/hello/:name’ do
  “Hello, #{params[:name]}!”
end
```

আপনি এটি http://first20hours.com/hello/name-এ দেখতে পারেন। "name"-এর জায়গায় আপনার নাম লিখতে দ্বিধা করবেন না। এটা কাজ করে!

এই অ্যাপ্লিকেশনটি সার্ভারকে রুটের "name" অংশে যা কিছু আছে তা দেখতে এবং তারপরে অ্যাপ্লিকেশনটিতে এটি ব্যবহার করার অনুমতি দিয়ে কাজ করে। রুটের কমান্ডটি ব্যবহারকারীকে "name" প্যারামিটারটি প্রদর্শন করার একটি সরল নির্দেশ।

সিনাত্রা আপনাকে প্যারামিটারগুলির নামকরণ করার অনুমতি দেয় (যেমন `:name`), তবে এটির একটি "ওয়াইল্ডকার্ড" প্যারামিটারও রয়েছে (যাকে "স্প্ল্যাট"ও বলা হয়) যা যেকোনো কিছু ধারণ করতে পারে। আমাদের সংশোধিত "Hello" অ্যাপ্লিকেশনে আমরা এটি কীভাবে ব্যবহার করব তা এখানে দেওয়া হল:

```ruby
get ‘/hello/*’ do
  “Hello, #{params[:splat]}!”
end
```

এটা বেশ দারুণ। নামকরণ করা প্যারামিটার এবং ওয়াইল্ডকার্ডের মধ্যে, আপনি কিছু খুব স্মার্ট রুট তৈরি করতে পারেন। আপনি যে রুটগুলি তৈরি করেন তা নির্ধারণ করে আপনার সিনাত্রা অ্যাপ্লিকেশনটি কীভাবে কাজ করে।

আমার লক্ষ্য কর্মক্ষমতার স্তর পূরণ করে এমন একটি প্রোগ্রাম লেখার জন্য এটি যথেষ্ট বিশদ। যেহেতু জেকিল ব্যবহারকারীর GET অনুরোধের প্রতিক্রিয়ায় অ্যাপ্লিকেশনটি যে আসল ফাইলগুলি সরবরাহ করবে তা তৈরি করছে, তাই আমাকে যা করতে হবে তা হল কয়েকটি রুট লেখা যা এই অনুরোধগুলি গ্রহণ করে, সিস্টেমে সঠিক ফাইলটি খুঁজে বের করে এবং এটিকে পাঠকের কাছে সরবরাহ করে।

জেকিলের ডকুমেন্টেশন অনুসারে, প্রোগ্রামটি সমাপ্ত ওয়েব পেজগুলিকে রুট ডিরেক্টরিতে "site" নামক একটি ফোল্ডারে রাখে। সেই পৃষ্ঠার রুট স্বয়ংক্রিয়ভাবে জেকিল দ্বারা তৈরি হয়। আমরা যদি আমাদের ওয়েবসাইটের About পেজটি http://example.com/about-এ উপলব্ধ করতে চাই, তবে আমরা আমাদের জেকিল ফাইলগুলিতে `/about` এর একটি রুট সেট করি এবং প্রোগ্রামটি আমাদের ওয়েবসাইটের রুট ফোল্ডারে `_site/about/index.html` ফাইলটি তৈরি করবে।

এর মানে হল ব্যবহারকারীর GET অনুরোধের প্রতিক্রিয়ায় একটি ফাইল পড়ার জন্য আমাকে সিনাত্রাতে একটি নতুন রুট তৈরি করতে হবে। এটি দেখতে এইরকম:

```ruby
# Index handler
get ‘/?’ do
  ## File.read(“_site/index.html”)
end

# Post handler
get ‘/*/?’ do
  ## File.read(“_site/#{params[:splat]}/index.html”)
end
```

`File.read(“”)` হল রুবিতে বিল্ট-ইন একটি কমান্ড। `File` একটি বস্তু এবং `.read` একটি পদ্ধতি। ব্যবহারটি বেশ সরল: ("") অংশে যা যায় তা হল প্রোগ্রামের রুট ফোল্ডারের সাপেক্ষে আপনি যে ফাইলটি পড়তে চান তার অবস্থান। সহজ।

যদি ফাইলটি বিদ্যমান না থাকে তবে কী হবে? তার জন্য একটি ব্যতিক্রমের প্রয়োজন, এবং সিনাত্রাতে দুটি মৌলিক ত্রুটি রুট বিল্ট-ইন রয়েছে: `not_found` এবং `error`। আসুন উভয় রুটকেই একই ত্রুটি পৃষ্ঠা ফেরত দিই:

```ruby
not_found do
  ## File.read(“_site/error/index.html”)
end

error do
  File.read(“_site/error/index.html”)
end
```

বাকি সব একই থাকে। আমি `config.ru` বা আমাদের `Gemfile`-এ কোনও পরিবর্তন করব না। আমি কেবল প্রোগ্রামের Git রিপোজিটরিতে নতুন রুটগুলি যোগ করছি, পরিবর্তনগুলি কমিট করছি এবং তারপরে আপডেট করা প্রোগ্রামটি হেরোকুতে পুশ করছি। সম্পন্ন।

আমাদের আপডেট করা প্রোগ্রামটি বাস্তবে কেমন দেখাচ্ছে তা দেখতে চান? PersonalMBA.com ভিজিট করুন: সাইটটি এখন এই একই প্রোগ্রাম ব্যবহার করে ওয়ার্ডপ্রেসের পরিবর্তে জেকিল চালাচ্ছে।

সিজ নামক একটি লোড-টেস্টিং প্রোগ্রাম ব্যবহার করে, আমার ওয়েবসাইটটি এখন কোনও ঘাম ঝরানো ছাড়াই দুই হাজারের বেশি সমসাময়িক পাঠককে পরিবেশন করতে সক্ষম। বেশিরভাগ পৃষ্ঠা অনুরোধ আঠারো থেকে পঁচিশ মিলি সেকেন্ডের মধ্যে সরবরাহ করা হয়, তাই ভারী ট্র্যাফিকের কারণে ক্র্যাশ হওয়া থেকে আমার সাইটটি এখন সম্পূর্ণরূপে সুরক্ষিত।

আমার প্রথম কার্যকরী ওয়েব অ্যাপ্লিকেশন সম্পূর্ণ। এই পদক্ষেপগুলি কীভাবে করতে হয় তা বের করতে আমার প্রায় এক ঘন্টা সময় লেগেছে এবং আমার ওয়েবসাইটের তথ্য এবং ডিজাইন ওয়ার্ডপ্রেস থেকে বের করে জেকিলে স্থানান্তর করতে আরও এক ঘন্টা সময় লেগেছে।

সম্পূর্ণ হতে মোট সময়: প্রায় দশ ঘন্টা, যার মধ্যে আমার গবেষণা এবং প্রোগ্রামিং ধারণা পর্যালোচনা অন্তর্ভুক্ত। খারাপ না!

**অ্যাপ্লিকেশন #২: কোডেক্স, একটি ব্যক্তিগত নোট ডাটাবেস**

আমার প্রথম অ্যাপ্লিকেশনটি কাজ করে এবং এটি ভালোভাবে কাজ করে। এটি সরল, তবে এই ক্ষেত্রে এটি একটি বড় সুবিধা। কম চলমান অংশ মানে প্রোগ্রামের ভেঙে যাওয়ার কম উপায়।

আসুন আরও কিছুটা জটিল কিছু দেখি।

আমাদের ডাটাবেস আলোচনা কি মনে আছে? বেসিক ওয়েব পেজগুলি নিজেরাই আপডেট করতে পারে না, তাই তারা তথ্য সংরক্ষণ করতে পারে না। প্রথম অ্যাপ্লিকেশনটি কেবল কাজ করে কারণ ফাইলগুলি স্ট্যাটিক: সেগুলি পরিবর্তিত হয় না। ফাইলগুলিতে কোনও পরিবর্তন জেকিলের মাধ্যমে করা হয়, যা একটি পৃথক প্রোগ্রাম। অ্যাপ্লিকেশনটি দ্রুত এবং স্থিতিশীল কারণ এটি কোনও ডাটাবেসের উপর নির্ভর করে না।

যে অ্যাপ্লিকেশনগুলি ডাটাবেস ব্যবহার করে সেগুলির কী হবে? ডাটাবেসগুলি সাধারণভাবে ওয়েব অ্যাপ্লিকেশনগুলির একটি বড় অংশ, তাই আমাকে বুঝতে হবে সেগুলি কীভাবে কাজ করে। সেগুলি কীভাবে কাজ করে তা শিখতে, আমাকে এমন একটি প্রকল্পে কাজ শুরু করতে হবে যা একটি ডাটাবেসের উপর নির্ভর করে।

আমি প্রতিদিন যে অ্যাপ্লিকেশনগুলি ব্যবহার করি তার মধ্যে একটি হল ব্যাকপ্যাক, যা ৩৭সিগন্যালস দ্বারা ডেভেলপ করা হয়েছিল। ব্যাকপ্যাকের প্রাথমিক সুবিধা হল "পেজ" তৈরি করা যা প্রায় সবকিছু ধারণ করতে পারে: টেক্সট, তালিকা, ছবি, ফাইল ইত্যাদি। আপনি যখন ব্যাকপ্যাকের কোনও পেজে তথ্য সংরক্ষণ করেন, তখন আপনি পরে যেকোনো কম্পিউটার থেকে এটি অ্যাক্সেস করতে পারেন, কারণ সমস্ত তথ্য অ্যাপ্লিকেশনটির ডাটাবেসে সংরক্ষিত থাকে।

আমার মনে হয়: আমি কি নিজে এরকম কিছু তৈরি করতে পারি? চেষ্টা করার মতো... তবে আমি কীভাবে শুরু করব?

জেকিল নিয়ে গবেষণা করার সময়, আমি টম প্রিস্টন-ওয়ার্নারের একটি প্রবন্ধ পড়েছিলাম, যিনি জেকিল তৈরি করেছিলেন, যার শিরোনাম ছিল "Readme Driven Development"। প্রবন্ধটির মূল কথা হল যে প্রতি কয়েক বছর পর পর সফ্টওয়্যার শিল্পে ভেসে আসা প্রকল্প ব্যবস্থাপনার ফ্যাডগুলির বিপরীতে, অ্যাপ্লিকেশন তৈরি করার সেরা উপায় হল অন্য কিছু করার আগে একটি Readme ডকুমেন্ট লেখা।

Readme হল একটি ফাইল যা প্রোগ্রামাররা কোডের পাশে অ্যাপ্লিকেশনটির রুট ফোল্ডারে অন্তর্ভুক্ত করে। ফাইলটিতে প্রোগ্রামটি কীভাবে সেট আপ, কনফিগার এবং ব্যবহার করতে হয় তার তথ্য থাকে। Readme ফাইলগুলি গুরুত্বপূর্ণ কারণ অনেক প্রোগ্রাম স্ব-ব্যাখ্যামূলক নয়। কিছুটা ডকুমেন্টেশন ছাড়া, কোনও প্রোগ্রাম কীভাবে ব্যবহার করতে হয় তা বের করা সাধারণত খুব কঠিন। নিজে কোড ঘেঁটে বের করার চেষ্টা করা মূল প্রোগ্রামার দ্বারা লিখিত একটি বিস্তারিত ব্যাখ্যা পড়ার মতো কার্যকর নয়।

টম যুক্তি দেন যে কোডিং শুরু করার আগে আপনার প্রোগ্রামের Readme ফাইলটি প্রথমে লেখা ভাল। বেশিরভাগ প্রোগ্রামার প্রথমে কোড করে, তারপর (হয়তো) Readme লেখে। এটি একটি সুযোগ হাতছাড়া করা: প্রথমে ডকুমেন্টেশন লেখা আপনাকে প্রোগ্রামটি কীভাবে কাজ করবে তা সঠিকভাবে বের করতে সাহায্য করে। Readme ডকুমেন্টেশন টুলের পাশাপাশি একটি ডিজাইন টুলও হতে পারে।

আমার কাছে এটা বোধগম্য মনে হয়। দ্য পার্সোনাল এমবিএ-এর উপর কাজ করার সময় আমি যে পণ্য উন্নয়ন কৌশলগুলি শিখেছিলাম তার মধ্যে একটি হল অফার তৈরি করার আগে বিক্রয় কপি লেখা, এটি সম্পন্ন হওয়ার পরে নয়। সম্ভাব্য ক্রেতারা কী চান তা বের করে এবং আপনার বিক্রয় কপিতে তা অন্তর্ভুক্ত করে, গ্রাহকদের আকর্ষণ করার জন্য পণ্যটি কী হতে হবে সে সম্পর্কে আপনি আরও সম্পূর্ণ ধারণা লাভ করেন। বিপণন গবেষণা অফারটির উন্নয়নকে নিজেই অবহিত করে।

আমি একটি নোটবুক বের করে অ্যাপ্লিকেশনটি কী কী করতে চাই তার একটি তালিকা লিখেছিলাম, সেইসাথে অ্যাপ্লিকেশনটির কী কী গুণাবলী থাকা উচিত:

* প্রোগ্রামটি একটি সরল রেফারেন্স এবং নোট-টেকিং অ্যাপ্লিকেশন।
* অ্যাপ্লিকেশনটি একক ব্যবহারকারীর জন্য ডিজাইন করা হয়েছে।
* অ্যাপ্লিকেশনটি পেজ রেকর্ড তৈরি, সংরক্ষণ, আপডেট এবং মুছে ফেলার জন্য সিনাত্রা এবং একটি ডাটাবেস ব্যবহার করে।
* অ্যাপ্লিকেশনটি ব্যবহারকারীকে বোল্ড, ইটালিক, শিরোনাম ইত্যাদি অভিনব ফরম্যাটিং সহ পেজ তৈরি করার অনুমতি দেয়।
* অ্যাপ্লিকেশনটি অ্যাক্সেস করার জন্য একটি পাসওয়ার্ডের প্রয়োজন এবং ডাটাবেসের তথ্য যতটা সম্ভব সুরক্ষিত রাখে।
* অ্যাপ্লিকেশনটি দেখতে সুন্দর।
* অ্যাপ্লিকেশনটি সহজেই হেরোকু বা অন্য কোনও অনুরূপ হোস্টে স্থাপন করা যেতে পারে।

আমি এই অ্যাপ্লিকেশনটির নাম কোডেক্স রাখতে যাচ্ছি, "বই"-এর একটি পুরনো শব্দ, যেহেতু অ্যাপ্লিকেশনটি প্রাথমিকভাবে রেফারেন্স তথ্য, তালিকা এবং এই জাতীয় জিনিসের জন্য দরকারী হবে।

এই ধরণের অ্যাপ্লিকেশনের জন্য ওয়েব প্রোগ্রামিংয়ের শিল্প শব্দ হল "CRUD", যার অর্থ হল ক্রিয়েট, রিড, আপডেট, ডিলিট। উল্লেখ করা মূল্যবান যে এই ফাংশনগুলি মূলত GET, POST, PUT, DELETE-এর মতোই, তাই সিনাত্রা রুট ব্যবহার করে এই ধরণের অ্যাপ্লিকেশন তৈরি করা অবশ্যই সম্ভব। বড় পার্থক্য হল একটি ডাটাবেসের প্রবর্তন।

হেরোকুতে কী ধরণের ডাটাবেস বিকল্প উপলব্ধ? আমি জানি না: ডকুমেন্টেশনে ফিরে যাই।

ডিফল্টরূপে, হেরোকু পোস্টগ্রেস নামক একটি ডাটাবেস ব্যবহার করে। প্রতিটি নতুন অ্যাপ্লিকেশনকে ডিফল্টরূপে একটি ছোট ডেভেলপমেন্ট ডাটাবেস বরাদ্দ করা হয়। এটি আমার জন্য কাজ করে, তবে আমি এটি কীভাবে ব্যবহার করব এবং আমার নিজের কম্পিউটারে প্রোগ্রামটি পরীক্ষা করার জন্য আমি কী ব্যবহার করব?
**ডেটাMapper প্রবেশ**

এই প্রশ্নগুলির উত্তর দেওয়ার জন্য, আমি Stack Overflow অনুসন্ধান করার সিদ্ধান্ত নিয়েছি। ঐকমত্য হল DataMapper নামক একটি লাইব্রেরি ব্যবহার করা এই ধরণের ডেভেলপমেন্টকে অনেক সহজ করে তোলে।

DataMapper হল এক ধরণের প্রোগ্রাম যাকে "অবজেক্ট রিলেশনাল ম্যাপার" বলা হয়, সাধারণত ORM-এ সংক্ষেপে লেখা হয়। ORM প্রোগ্রামারদের জন্য একটি জরুরি সমস্যা সমাধান করে: ডাটাবেসগুলি প্রায়শই তাদের নিজস্ব ভাষা ব্যবহার করে, যা প্রোগ্রামার অ্যাপ্লিকেশন তৈরি করতে যে ভাষা ব্যবহার করে তার থেকে আলাদা। সবচেয়ে সাধারণ ডাটাবেস ভাষার নাম SQL, তবে আরও শত শত ভাষা রয়েছে।

ধরুন আমরা Amazon.com-এর একজন প্রোগ্রামার এবং আমরা হ্যারি পটার সিরিজের লেখক জে. কে. রাউলিংয়ের বইগুলির একটি তালিকা প্রদর্শন করতে চাই। SQL কমান্ডটি দেখতে এইরকম হতে পারে:

```sql
SELECT * FROM Book WHERE author = “J.K. Rowling” ORDER BY title;
```

এই কমান্ডটি Book ডাটাবেসের সমস্ত রেকর্ড পুনরুদ্ধার করে যেখানে লেখক ফিল্ডে "J.K. Rowling" রয়েছে এবং সেগুলিকে শিরোনাম অনুসারে বর্ণানুক্রমিকভাবে ফেরত দেয়।

দুর্ভাগ্যবশত, রুবি-এর মতো ভাষার সাথে SQL বা অন্য কোনও ডাটাবেস ক্যোয়ারী ভাষাকে ভালোভাবে কাজ করানো কঠিন হতে পারে। এক ভাষায় প্রোগ্রামিং করাই যথেষ্ট কঠিন, একই সাথে একাধিক ভাষায় তো আরও কঠিন।

ঠিক এখানেই ORM-এর আগমন: এগুলি প্রোগ্রামারকে এক ভাষায় কোড লিখতে দেয়, যা ORM তখন ডাটাবেসের ভাষায় অনুবাদ করে। অনেক সহজ।

তাহলে DataMapper হল একটি লাইব্রেরি যা রুবি ব্যবহার করে ডাটাবেসের সাথে যোগাযোগ করা অনেক সহজ করে তোলে। ডিফল্টরূপে, DataMapper ডাটাবেস রেকর্ড তৈরি, পড়া, আপডেট এবং মুছে ফেলার জন্য অনেক দরকারী বৈশিষ্ট্য সরবরাহ করে। যেহেতু DataMapper বেশ কিছুদিন ধরে রয়েছে এবং পুঙ্খানুপুঙ্খভাবে পরীক্ষা করা হয়েছে, তাই বেশিরভাগ ক্ষেত্রে নিজের ডাটাবেস কোড লেখার চেষ্টা করার চেয়ে এটি বেশি নির্ভরযোগ্য।

DataMapper একটি জেম হিসাবে উপলব্ধ, যা এইভাবে ইনস্টল করা হয়:

```bash
$ gem install data_mapper
```

যেহেতু DataMapper এত বড় একটি লাইব্রেরি, তাই এটিকে খণ্ড খণ্ড করে ইনস্টল করাও সম্ভব। এটি "মডুলারিটি" নামক একটি ধারণা এবং এটি ভালো প্রোগ্রামিংয়ের একটি বৈশিষ্ট্য। সমস্ত স্বতন্ত্র জেম ইনস্টল করার কমান্ডটি এখানে দেওয়া হল:

```bash
$ gem install dm-core dm-aggregates dm-constraints dm-migrations dm-transactions dm-serializer dm-timestamps dm-validations dm-types
```

পুরো লাইব্রেরি ইনস্টল করার পরিবর্তে, আপনি কেবল সেই অংশগুলি ইনস্টল করতে পারেন যা আপনার প্রোগ্রাম ব্যবহার করবে, যা অনেক বেশি কার্যকর।

**DataMapper ব্যবহার**

এখন যেহেতু DataMapper ইনস্টল করা হয়েছে, আমাকে এটি (১) ডাটাবেসের সাথে কথা বলতে এবং (২) আমি যে তথ্য সংরক্ষণ ও পুনরুদ্ধার করতে চাই তার জন্য ডাটাবেস সেট আপ করতে কীভাবে ব্যবহার করতে হয় তা বের করতে হবে।

হেরোকুর পোস্টগ্রেস ডকুমেন্টেশনের উপর ভিত্তি করে, নিম্নলিখিত কমান্ডটি আমার সিনাত্রা অ্যাপ্লিকেশনকে ডাটাবেসের সাথে কথা বলার অনুমতি দেবে:

```ruby
DataMapper.setup(:default, ENV[‘DATABASE_URL’] || “sqlite3://#{Dir.pwd}/database.db”)
```

এই ক্ষেত্রে, `||` "অথবা" বলার আরেকটি উপায়। `ENV[‘DATABASE_URL’]` হল একটি ভেরিয়েবল যা হেরোকু আপনার অ্যাপ্লিকেশনের ডাটাবেসের প্রতিনিধিত্ব করতে ব্যবহার করে। যদি সেই ডাটাবেসটি উপলব্ধ না থাকে, তবে এটি দ্বিতীয় বিকল্পটি ব্যবহার করবে, Sqlite নামক একটি ডাটাবেস।

Sqlite ম্যাক কম্পিউটারে ডিফল্টরূপে ইনস্টল করা থাকে, তাই এটি ব্যবহারের জন্য প্রস্তুত।

যদি আমি এই দুটি জেম ইনস্টল করি তবে DataMapper পোস্টগ্রেস এবং Sqlite উভয়ের সাথেই কথা বলতে পারে:

```bash
$ gem install dm-sqlite-adapter dm-postgres-adapter
```

এর অর্থ হল আমার অ্যাপ্লিকেশনটি হেরোকুতে চলার সময় পোস্টগ্রেস ব্যবহার করবে, তবে আমার কম্পিউটারে চলার সময় Sqlite ব্যবহার করবে। উভয় ক্ষেত্রেই, আমার কোড একই থাকবে, যদিও ডাটাবেসগুলি ভিন্ন ভাষা বলে। এটা সত্যিই দারুণ।

আমার কম্পিউটারে এই অ্যাপ্লিকেশনটি চালানোর কথা বলছি... আমি সেটা কীভাবে করব?

**পাও!**

আমি আমার মেশিনে স্থানীয়ভাবে এই ধরণের অ্যাপ্লিকেশন কীভাবে চালানো যায় সে সম্পর্কে তথ্যের জন্য Stack Overflow এবং Hacker News অনুসন্ধান করেছি। সৌভাগ্যবশত, কয়েকটি বিকল্প রয়েছে। দেখে মনে হচ্ছে আমি লাইব্রেরি (যেমন Foreman বা Shotgun) ইনস্টল করতে পারি যা টার্মিনালে একটি কমান্ড প্রবেশ করলে অ্যাপ্লিকেশনটি চালাবে, অথবা আমি এমন একটি প্রোগ্রাম ইনস্টল করতে পারি যা প্রোগ্রামটিকে সর্বদা চালু রাখে।

দ্বিতীয় পদ্ধতিটি গ্রহণ করে এমন একটি প্রোগ্রাম হল Pow, "ম্যাক ওএস এক্স-এর জন্য একটি জিরো-কনফিগারেশন র্যাক সার্ভার"। সাইটটি এক মিনিটেরও কম সময়ে আমার কম্পিউটারে স্থানীয় ডেভেলপমেন্ট হোস্টিং সেট আপ করা সহজ করার প্রতিশ্রুতি দেয়। আমার কাছে দারুণ শোনাচ্ছে!

Pow ইনস্টল করতে প্রায় দশ সেকেন্ড সময় লাগে: অ্যাপ্লিকেশনটি ডাউনলোড এবং ইনস্টল করার জন্য এটি একটি একক টার্মিনাল কমান্ডের প্রয়োজন। ইনস্টল হয়ে গেলে, আপনি আপনার প্রোগ্রামটিকে Pow-এর সাথে লিঙ্ক করার জন্য একটি কমান্ড চালান এবং Pow আপনাকে আপনার মেশিনে এটি চালানোর অনুমতি দেবে।

পাউডার নামক একটি রুবি জেম রয়েছে যা এই প্রক্রিয়াটিকে আরও সহজ করে তোলে:

```bash
$ gem install powder
```

জেমটি ইনস্টল হয়ে গেলে, Pow ইনস্টল করার জন্য আপনি এটি চালান:

```bash
$ powder install
```

তারপরে, আপনি আপনার অ্যাপ্লিকেশনের রুট ডিরেক্টরিতে যান এবং এই কমান্ডটি প্রবেশ করেন:

```bash
$ powder link
```

এইটুকুই। আমার রুট ডিরেক্টরির নাম "codex", তাই আমার অ্যাপ্লিকেশনটি এখন [http://codex.dev-](http://codex.dev-)এ আমার ব্যক্তিগত মেশিনে চলছে এবং আমি আমার কাজ পরীক্ষা করতে পারি।

যদি আমি কোনও পরিবর্তন করি, এই কমান্ডটি প্রোগ্রামটি পুনরায় চালু করে:

```bash
$ powder restart
```

সহজ। আমি এখন তৈরি করার জন্য প্রস্তুত। আমি প্রতিদিন সন্ধ্যায় দেড় ঘন্টা কোডিং করার জন্য আলাদা করে রাখি এবং এটি শেষ না হওয়া পর্যন্ত চালিয়ে যাব।

**কোড, পরীক্ষা, সংশোধন**

এই মুহুর্তে, আমি কী করছি বনাম কীভাবে করছি তা বর্ণনা করতে যাচ্ছি। আপনি যদি অনুসরণ করতে চান তবে [https://github.com/first20hours/codex-এ](https://www.google.com/search?q=https://github.com/first20hours/codex-%E0%A6%8F) সম্পূর্ণ কোড দেখতে পারেন।

শেষ হলে অ্যাপ্লিকেশনটি দেখতে কেমন হবে তা এখানে দেওয়া হল:

আপনি লক্ষ্য করবেন এই ডিজাইনের তিনটি অংশ রয়েছে: একটি উপরের নেভিগেশন বার, একটি প্রধান কন্টেন্ট এরিয়া এবং একটি সাইডবার। আমি বুটস্ট্র্যাপ ব্যবহার করে এই বেসিক ডিজাইন তৈরি করেছি, যা মার্ক অটো এবং জ্যাকব থর্নটন তৈরি করেছিলেন, উভয়েই টুইটারের ডেভেলপার।

স্ক্র্যাচ থেকে একটি ওয়েব ডিজাইন তৈরি করার পরিবর্তে, বুটস্ট্র্যাপ হল প্রি-লিখিত HTML এবং CSS-এর একটি লাইব্রেরি যা বিনামূল্যে ব্যবহার করা যায়। বুটস্ট্র্যাপ প্রচুর সময় বাঁচায়: আপনি দিনের পরিবর্তে মিনিটের মধ্যে কোনও অ্যাপ্লিকেশন কেমন দেখতে চান তার একটি মৌলিক প্রোটোটাইপ তৈরি করতে পারেন।

এই অ্যাপ্লিকেশনটির মৌলিক একক হল একটি "পেজ", যা ডাটাবেসে সংরক্ষিত একটি রেকর্ড প্রদর্শন করে। পেজের তথ্য প্রধান কন্টেন্ট এরিয়াতে যায়। ডাটাবেসের সমস্ত পেজের তালিকা দেখায় এমন একটি স্ক্রিনে যাওয়ার জন্য একটি বোতাম রয়েছে এবং নীচে দুটি বোতাম রয়েছে। প্রথম বোতামটি আপনাকে বর্তমান পেজটি সম্পাদনা করার অনুমতি দেয় এবং দ্বিতীয়টি আপনাকে এটি মুছে ফেলার অনুমতি দেয়।

সাইডবারে তিনটি প্রধান বৈশিষ্ট্য রয়েছে। শীর্ষে, একটি ফর্ম রয়েছে যা আপনাকে একটি নতুন পেজ তৈরি করার অনুমতি দেয়, যার জন্য একটি শিরোনামের প্রয়োজন। দ্বিতীয়ত, ব্যবহারকারী সাইডবারে যোগ করা পেজগুলির একটি তালিকা রয়েছে, যা একটি দ্রুত রেফারেন্স বিভাগ হিসাবে কাজ করে। তৃতীয়ত, একটি ফরম্যাটিং রেফারেন্স রয়েছে, যা ব্যবহারকারীকে সাধারণ ফরম্যাটিং বৈশিষ্ট্যগুলি কীভাবে ব্যবহার করতে হয় তা মনে রাখতে সাহায্য করে।

শীর্ষের নেভিগেশন বারটি বেশ সরল। এতে হোম পেজের একটি লিঙ্ক, সেইসাথে "List all pages" স্ক্রিনের একটি দ্বিতীয় লিঙ্ক রয়েছে। আমি চাইলে পরে নেভিগেশন বারে অতিরিক্ত আইটেম যোগ করতে পারি, তবে আপাতত আমার এটুকুই দরকার।

প্রতিটি ওয়েব অ্যাপ্লিকেশনের একটি হোম পেজ থাকে, তাই সেই পৃষ্ঠায় আমি কী রাখতে চাই তা আমাকে সিদ্ধান্ত নিতে হবে। এই ক্ষেত্রে, আমি কেবল ডাটাবেসের হোম রেকর্ডটি প্রদর্শন করতে চাই।

তাহলে একটি পেজে কী থাকে? যেহেতু প্রতিটি পেজ একটি ডাটাবেস রেকর্ড এবং রেকর্ডগুলিতে আসল তথ্য ধারণকারী ফিল্ড রয়েছে, তাই DataMapper-কে কোন ফিল্ডগুলি সেট আপ করতে হবে তা আমাকে বলতে হবে। এখানে কোডটি দেওয়া হল:

```ruby
class Page
  include DataMapper::Resource

  property :id, Serial
  property :title, String
  property :content, Text
  property :lastupdated, DateTime
end

DataMapper.finalize
```

এই কোডটি DataMapper ব্যবহার করে Page নামক একটি নতুন ধরণের বস্তু তৈরি করে। রুবি এখন অন্য যেকোনো বস্তুর মতো Page ব্যবহার করতে পারে এবং আমি Page তৈরি, পরিবর্তন এবং মুছে ফেলার জন্য পদ্ধতি তৈরি এবং ব্যবহার করতে পারি। আমি যখন কোনও Page-এ পরিবর্তন করি, তখন সেই পরিবর্তন DataMapper-এর মাধ্যমে ডাটাবেসে সংরক্ষিত হয়।

`Datamapper.finalize` কমান্ডটি অ্যাপ্লিকেশনটিকে প্রকৃত ডাটাবেসে এই ফিল্ডগুলি সেট আপ করতে বলে যদি সেগুলি ইতিমধ্যেই বিদ্যমান না থাকে।

এখন যেহেতু আমার ডাটাবেস সেট আপ করা হয়েছে, সিনাত্রা কোন রুটগুলি পরিবেশন করার আশা করবে তা বের করার সময় এসেছে। এ পর্যন্ত আমি যা জানি তার উপর ভিত্তি করে আমার তালিকা এখানে দেওয়া হল:

```ruby
# Show home page
get ‘/’

# Creates new note from “new page” form
post ‘/’

# Displays requested note
get ‘/:url/’

# Edits requested note
get ‘/:url/edit’

# Saves user edits to note
post ‘/:url/edit’

# Deletes specified note
delete ‘/:url/’

# List all pages in database
get ‘/all/’

# Error handling
not_found
error
```

এটি বেশ ভালো তালিকা। আমার অ্যাপ্লিকেশনটি প্রতিটি রুটের জন্য আমি কী কমান্ড তৈরি করি তার উপর নির্ভর করবে।

**স্লাগ, সর্বত্র স্লাগ!**

মনে আছে আমি কখন উল্লেখ করেছিলাম যে ডাটাবেসগুলি কিছুটা জাদুকরী ইনডেক্স কার্ডের স্তূপের মতো এবং আপনি যেভাবে চান সেগুলি অনুসন্ধান করতে পারেন? আমাদের নির্দিষ্ট পেজ রেকর্ডগুলি অনুসন্ধান করার একটি উপায় দরকার, তাই আপনি এই রুটগুলিতে `:url` দেখতে পাচ্ছেন। `url` প্যারামিটারের বিষয়বস্তু ডাটাবেসকে কোন রেকর্ডটি পুনরুদ্ধার করতে হবে তা বলবে।

আমরা প্যারামিটার হিসাবে পেজের শিরোনাম ব্যবহার করতে পারতাম, তবে এতে একটি সমস্যা রয়েছে: ওয়েব ব্রাউজারগুলি ওয়েব ঠিকানাগুলিতে স্পেস, বড় অক্ষর এবং বিশেষ অক্ষর (যেমন $ এবং %) পছন্দ করে না। পেজের শিরোনামগুলিতে সেগুলি অন্তর্ভুক্ত থাকতে পারে, তাই সেগুলি সরানোর জন্য আপনার একটি উপায় থাকা দরকার।

একটি স্ট্রিং যা একটি ওয়েবসাইট পেজকে অনন্যভাবে চিহ্নিত করে তাকে স্লাগ বলা হয়। আমার পেজ স্লাগ পেজের শিরোনামের উপর ভিত্তি করে তৈরি হবে, এটিকে ওয়েব-ঠিকানা বন্ধুত্বপূর্ণ করার জন্য নিম্নলিখিত নিয়মগুলি সহ:

১. সমস্ত অক্ষর ছোট হাতের হবে।
২. কোনও বিশেষ অক্ষর নয়—কেবল আলফানিউমেরিক।
৩. কোনও স্পেস নয়—সমস্ত স্পেস একটি ড্যাশ দিয়ে প্রতিস্থাপিত করা উচিত।

এটি করার উপায় হল একটি পদ্ধতি তৈরি করা যা পেজের শিরোনাম গ্রহণ করে, তারপর এটিকে স্লাগ বিন্যাসে রূপান্তর করে। জটিল প্রতিস্থাপনগুলি নিয়মিত অভিব্যক্তি নামক এক ধরণের প্রোগ্রামিং দ্বারা যত্ন নেওয়া হয়, যা প্রদত্ত নিয়মের উপর ভিত্তি করে স্ট্রিংগুলির মধ্যে টেক্সট রূপান্তর বা খুঁজে বের করে। নিয়মিত অভিব্যক্তি খুব রহস্যময় হতে পারে, তবে এটি একটি সাধারণ ব্যবহার, তাই আমি একটি বয়লারপ্লেট উদাহরণ খুঁজে পেতে সক্ষম হয়েছিলাম। এখানে আমার পদ্ধতি:

```ruby
# Converts page name into post slug
def slugify(content)
  content.downcase.gsub(/ /, ‘-’).gsub(/[^a-z0-9-]/, “”).squeeze(‘-’)
end
```

এখন, আমি "Page Title"-এর মতো একটি স্ট্রিংকে "page-title"-এ রূপান্তর করতে `slugify` পদ্ধতিটি ব্যবহার করতে পারি, যা এটিকে ওয়েব ঠিকানায় ব্যবহারের জন্য উপযুক্ত করে তোলে।

এছাড়াও, যদি আমরা পেজের শিরোনামের পাশে স্লাগটি সংরক্ষণ করি, তবে আমরা `:url` প্যারামিটার ব্যবহার করে পেজ রেকর্ডটি পুনরুদ্ধার করতে এটি ব্যবহার করতে পারি।

আমি DataMapper ক্লাসে এই ফিল্ডটি যুক্ত করেছি:

```ruby
property :slug, String
```

এখন, যখনই আমরা একটি পেজ তৈরি করি, আমরা পেজের শিরোনামটিকে "স্লাগিফাই" করতে পারি, এটিকে ডাটাবেসে সংরক্ষণ করতে পারি এবং যখন আমরা এটিকে পুনরুদ্ধার করতে চাই তখন আবার পেজটি দেখাতে এটি ব্যবহার করতে পারি। অ্যাপ্লিকেশনটি কীভাবে কোন পেজটি দেখাতে হবে তা জানবে।

**পেজ তৈরি**

আমি প্রয়োজনীয় রুটগুলির তালিকা ধরে কাজ শুরু করি। "হোম" রুটটি সহজ: আমি এটিকে `/home/` স্লাগে পুনঃনির্দেশিত করি, কারণ আমি হোম পেজে হোম রেকর্ডটি দেখাতে চাই।

"পেজ তৈরি করুন" রুটটি সাইডবারের উপরের ছোট ফর্মের সাথে লিঙ্ক করা আছে। ব্যবহারকারী ফর্মে পেজের শিরোনাম প্রবেশ করে, তারপর বোতামে ক্লিক করে। সিস্টেম পেজের শিরোনাম ক্যাপচার করে, এটিকে স্লাগিফাই করে, তারপর শিরোনাম, স্লাগ এবং সৃষ্টির সময় ডাটাবেসে সংরক্ষণ করে। তারপরে এটি স্লাগ ধারণকারী একটি GET অনুরোধ পাঠায়, নতুন পেজটি প্রদর্শন করে।

"পেজ তৈরি করুন" রুটে একটি ছোট বিবরণ রয়েছে যা খুব গুরুত্বপূর্ণ: যদি পেজটি ইতিমধ্যেই বিদ্যমান থাকে তবে কী হবে? যদি এতে ইতিমধ্যেই ডেটা থাকে তবে আমি পেজটি ওভাররাইট করতে চাই না। দুর্ঘটনাক্রমে ডেটা হারানো অগ্রহণযোগ্য।

সৌভাগ্যবশত, DataMapper বিল্ট-ইন `.first_or_create` পদ্ধতি দিয়ে এই বিশেষ সমস্যাটি সমাধান করে। পেজ তৈরি করার আগে, DataMapper পরীক্ষা করবে এটি ইতিমধ্যেই বিদ্যমান কিনা। যদি পেজটি বিদ্যমান থাকে তবে DataMapper এটিকে ওভাররাইট করবে না এবং সিনাত্রা পরিবর্তে ব্রাউজারটিকে বিদ্যমান পেজে পুনঃনির্দেশিত করবে। সমস্যার সমাধান।

"পেজ প্রদর্শন করুন" রুটটি URL-এ স্লাগটি পড়ে, ডাটাবেস থেকে রেকর্ডটি পুনরুদ্ধার করে, তারপর প্রধান কন্টেন্ট এরিয়াতে তথ্য প্রদর্শন করে। পরে, আমি কিছু অভিনব ফরম্যাটিং যোগ করব, তবে আপাতত, আমি কেবল এটি কাজ করতে চাই।

**পেজ সম্পাদনা**

একটি পেজ সম্পাদনা করার জন্য দুটি পৃথক রুট জড়িত। প্রথম রুটটি ব্যবহারকারী যে পেজটি সম্পাদনা করতে চায় সেটি GET করে, তারপর ব্যবহারকারী সম্পাদনা করতে পারে এমন ফর্মে পেজ রেকর্ডের বিষয়বস্তু প্রদর্শন করে।

এই পেজগুলি প্রদর্শন করার জন্য, অ্যাপ্লিকেশনটি ERB নামক একটি টেমপ্লেট সিনট্যাক্সের উপর নির্ভর করে, যা মূলত HTML + রুবি কমান্ড। ERB প্রোগ্রামারদের পরিবর্তনযোগ্য উপাদান সহ HTML লিখতে দেয়।

যেহেতু ERB ব্যবহারকারীর কাছে প্রদর্শিত হওয়ার আগে পেজটি প্রক্রিয়া করে, তাই টেমপ্লেটের রুবি কমান্ডের উপর ভিত্তি করে প্রতিবার পেজ লোড হওয়ার সময় এটি পেজের টেক্সট পরিবর্তন করতে পারে।

সম্পাদনা স্ক্রিনের Save বোতামটি অ্যাপ্লিকেশনটিতে একটি POST অনুরোধ পাঠায় যা পেজ রেকর্ড আপডেট করে।

**পেজ মুছে ফেলা**

পেজ মুছে ফেলার জন্য কিছু সতর্কতা প্রয়োজন: মনে রাখবেন, দুর্ঘটনাক্রমে ডেটা হারানো অগ্রহণযোগ্য। আপনি যদি কোনও পেজ মুছে ফেলতে যাচ্ছেন তবে আপনি অবশ্যই নিশ্চিত হতে চান যে ব্যবহারকারী আসলে সেই পেজটি মুছে ফেলতে চান।

এটি করার ভুল উপায় হবে অ্যাপ্লিকেশনটিতে সরাসরি DELETE রুটের সাথে একটি ডিলিট বোতাম লিঙ্ক করা। সেই পদ্ধতিটি ব্যবহারকারী দুর্ঘটনাক্রমে বোতামে ক্লিক করলেও পেজটি মুছে ফেলবে।

একটি ভাল কৌশল হল দুটি ধাপের প্রক্রিয়া ব্যবহার করা। একটি পেজের Delete বোতামে ক্লিক করলে ব্যবহারকারীকে একটি নিশ্চিতকরণ স্ক্রিনে নিয়ে যাওয়া হয় যা ব্যবহারকারী যে পেজটি মুছে ফেলতে চান তার শিরোনাম প্রদর্শন করে। যদি ব্যবহারকারী এগিয়ে যেতে চান তবে তারা একটি নিশ্চিতকরণ বোতামে ক্লিক করতে পারেন যা DELETE অনুরোধ পাঠায়। যদি ব্যবহারকারী দুর্ঘটনাক্রমে Delete বোতামে ক্লিক করে থাকেন তবে তারা তাদের ব্রাউজারে Cancel বা Back বোতাম টিপতে পারেন।

**সমস্ত পেজের তালিকা**

"List all Pages" ব্যবহারকারীকে `/all/` স্লাগে পুনঃনির্দেশিত করে, যা নিয়মিত পেজ থেকে আলাদা।

একটি একক রেকর্ড পুনরুদ্ধার করার পরিবর্তে, DataMapper ডাটাবেসের সমস্ত পেজ রেকর্ড পুনরুদ্ধার করে। পেজের ERB টেমপ্লেটে একটি শর্তাধীন লুপ রয়েছে যা পুনরুদ্ধার করা প্রতিটি পেজের জন্য একটি তালিকা আইটেম তৈরি করে। প্রতিটি আইটেমে পেজের শিরোনাম থাকে, যা সেই পেজের সাথে যুক্ত স্লাগ ধারণকারী একটি লিঙ্ক হিসাবে প্রদর্শিত হয়। লিঙ্কে ক্লিক করলে ব্যবহারকারী পৃথক পেজ রেকর্ডে চলে যায়।

**প্রথমবার অ্যাপ্লিকেশন চালু করা**

আমার কাছে মৌলিক বৈশিষ্ট্যগুলি রয়েছে, তবে আমার একটি সমস্যা হচ্ছে: হোম পেজ ভিজিট করে অ্যাপ্লিকেশনটি পরীক্ষা করার সময়, আমি অবিলম্বে একটি ত্রুটি বার্তা পাই। প্রোগ্রামটি ডাটাবেসে হোম রেকর্ডটি খুঁজে বের করার চেষ্টা করছে, তবে এটি বিদ্যমান নেই, কারণ আমি এইমাত্র অ্যাপ্লিকেশনটি শুরু করেছি!

এর সমাধান হল Rake নামক একটি প্রোগ্রাম ব্যবহার করে একটি "এককালীন প্রশাসনিক প্রক্রিয়া" তৈরি করা। Rake প্রোগ্রামগুলি একটি Rakefile-এ সংরক্ষণ করা হয়, যা অ্যাপ্লিকেশনটির রুট ফোল্ডারে অবস্থিত। Rakefile নিয়মিত রুবি অ্যাপ্লিকেশনগুলির মতোই কাজ করে, একটি ব্যতিক্রম ছাড়া: এগুলি আপনার মূল প্রোগ্রামের বাইরে বিদ্যমান এবং আপনাকে ম্যানুয়ালি কমান্ডগুলি চালাতে হবে।

এটি Rake-কে প্রোগ্রামটি আনুষ্ঠানিকভাবে চালানোর আগে ডাটাবেসে ডিফল্ট তথ্য যোগ করার মতো কাজ করার জন্য খুব দরকারী করে তোলে। আমি `application.rb`-এর গুরুত্বপূর্ণ অংশগুলি Rakefile-এ অনুলিপি করি, তারপর ডাটাবেসে একটি নতুন "Home" পেজ তৈরি করে এমন একটি কমান্ড তৈরি করি। তারপরে, আমাকে যা করতে হবে তা হল একবার এই কমান্ডটি চালানো:

```bash
$ rake setup
```

Rake "Home" পেজ রেকর্ড তৈরি করে এবং আমার অ্যাপ্লিকেশনটি শুরুতে ত্রুটি দেখানো বন্ধ করে দেয়। আমি যখন এই অ্যাপ্লিকেশনটি হেরোকুতে পুশ করব, তখন অ্যাপ্লিকেশনটি ব্যবহার করার চেষ্টা করার আগে ডাটাবেস সেট আপ করার জন্য আমি দূরবর্তীভাবে Rake কমান্ডটি চালাব।

এই মুহুর্তে, আমাদের কাছে সমস্ত প্রধান বৈশিষ্ট্য রয়েছে। এখন, কিছু মজার জিনিস যোগ করার সময়।

**সাইডবার সমর্থন যোগ করা**

আমি এইমাত্র বুঝতে পেরেছি যে আমি সাইডবারে পেজ যোগ করার কোনও উপায় অন্তর্ভুক্ত করিনি, যেমনটি আমি মূলত চেয়েছিলাম। এই ধরণের বৈশিষ্ট্যের জন্য একটি বুলিয়ান প্রয়োজন, যেহেতু এটির কেবল দুটি মান রয়েছে: পেজটি সাইডবারে প্রদর্শিত হওয়ার কথা, অথবা নয়।

আমি DataMapper ক্লাসে এটি যোগ করেছি:

```ruby
property :sidebar, Boolean, :default => false
```

আমি "সাইডবারে অন্তর্ভুক্ত করুন?" এর পাশে "সম্পাদনা" স্ক্রিনে একটি চেকবক্সও যোগ করি, যা আমি ডাটাবেসের সাইডবার ফিল্ডের সাথে লিঙ্ক করি। তারপরে আমি ডাটাবেসে `:
sidebar = true` যেখানে সেই রেকর্ডগুলি খুঁজে বের করার জন্য একটি সরল লুপ লিখি, তারপর সেগুলিকে "List all" পেজের মতোই একটি তালিকা হিসাবে প্রদর্শন করি।

আমি অ্যাপ্লিকেশনটি পুনরায় চালু করি, একটি রেকর্ড সম্পাদনা করি এবং পুরো অ্যাপ্লিকেশনটি ক্র্যাশ করে। ইয়াইক্স!

আমি কী ভুল হচ্ছে তা বের করার চেষ্টা করি এবং চেষ্টা করি, তবে আমার কোনও ভাগ্য নেই।

DataMapper ডকুমেন্টেশন এবং Stack Overflow অনুসন্ধানের পরে, আমি জানতে পারি যে এই উপায়ে বুলিয়ান ভেরিয়েবল ব্যবহার করা HTML ফর্মের সাথে ভালোভাবে মেলে না। অন্য একটি পদ্ধতির প্রয়োজন:

```ruby
property :sidebar, Enum[ :yes, :no ], :default => :no
```

এটি মূলত একই জিনিস করার আরেকটি উপায়। Enum, যার অর্থ "গণনা করা", বিকল্পগুলির একটি তালিকা তৈরি করে এবং ফর্মটি ডাটাবেসে কোন বিকল্পটি সংরক্ষণ করতে হবে তা সেট করে।

**Markdown সমর্থন যোগ করা**

এখন আমি নিশ্চিত করতে চাই যে আমার পেজগুলিতে ইটালিক, বোল্ড টেক্সট এবং শিরোনামের মতো অভিনব ফরম্যাটিং থাকতে পারে।

আমি ফরম্যাটিং সিনট্যাক্স হিসাবে Markdown বেছে নিয়েছি, যা জন গ্রুবার তৈরি করা একটি জনপ্রিয় এবং খুব দরকারী ছোট মার্কআপ ভাষা। আমি ইতিমধ্যেই একজন ব্যবহারকারী হিসাবে Markdown কীভাবে কাজ করে তা পরিচিত, কারণ আমার কম্পিউটারে ব্যবহৃত কয়েকটি অ্যাপ্লিকেশন এটি অন্তর্ভুক্ত করে। তবে, আমাকে বের করতে হবে কীভাবে আমার প্রোগ্রাম এটিকে বুঝতে পারবে।

কিছু অনুসন্ধান আমাকে বলে যে বেশ কয়েকটি Markdown জেম উপলব্ধ রয়েছে। আমি rdiscount লাইব্রেরিটি বেছে নিয়েছি, যা আমি `application.rb`-এ অন্তর্ভুক্ত করেছি:

```ruby
require ‘rdiscount’
```

Rdiscount Markdown বিন্যাসে লেখা টেক্সটকে HTML-এ রূপান্তর করে: ব্যবহারকারীর ওয়েব ব্রাউজার তখন সঠিক ফরম্যাটিং সহ সেই টেক্সটটি প্রদর্শন করে। Markdown ফাইলগুলি নিজেরাই বিশেষ কিছু নয়: সেগুলি কেবল নির্দিষ্ট উপায়ে লেখা টেক্সট ফাইল।

এর মানে হল ডাটাবেসে যোগ করার আগে আমার পেজের তথ্য Markdown-এ রূপান্তর করার দরকার নেই। এটি কেবল টেক্সট, সর্বোপরি। অভিনব ফরম্যাটেড টেক্সট দেখাতে চাইলে আমাকে কেবল rdiscount কল করতে হবে।

এখানে সেই কমান্ডটি দেওয়া হল যা কাজটি করে, যা আমি পেজ দেখানোর জন্য দায়ী ERB টেমপ্লেটগুলিতে যুক্ত করেছি:

```erb
<%
  markdown(@page.content)
%>
```

পদ্ধতিটি পেজের কন্টেন্ট ফিল্ডে টেনে আনে, এটিকে HTML-এ রূপান্তর করে, তারপর ব্যবহারকারীকে শেষ ফলাফল প্রদর্শন করে। সহজ।

**নিরাপত্তা যোগ করা**

লগইন তথ্যের কী হবে? যদি আমি কোনও ব্যবহারকারীর নাম এবং পাসওয়ার্ডের প্রয়োজন ছাড়াই এই অ্যাপ্লিকেশনটি হেরোকুতে রাখি, তবে যে কেউ ডাটাবেসে আমি যা সংরক্ষণ করেছি তা দেখতে পারবে।

দেখা যাচ্ছে, আধুনিক ওয়েব ব্রাউজারগুলি HTTP বেসিক অথেন্টিকেশন নামক একটি সুরক্ষা প্রোটোকল সমর্থন করে, যা ব্যবহারকারীকে এগিয়ে যাওয়ার আগে একটি ব্যবহারকারীর নাম এবং পাসওয়ার্ড প্রবেশ করানো বাধ্যতামূলক করার একটি সহজ উপায়। যদি ব্যবহারকারী অ্যাক্সেস শংসাপত্র সরবরাহ করতে না পারে, তবে তাদের একটি ত্রুটি পৃষ্ঠায় পুনঃনির্দেশিত করা হয়।

সিনাত্রাতে বেসিক অথেন্টিকেশন সক্ষম করার কোডটি এখানে দেওয়া হল:

```ruby
use Rack::Auth::Basic, “Restricted Area” do |username, password|
  [username, password] == [ENV[‘ADMIN_USER’], ENV[‘ADMIN_PASS’]]
end
```

এই ক্ষেত্রে, আমি হেরোকুতে পরিবেশ ভেরিয়েবল হিসাবে প্রকৃত ব্যবহারকারীর নাম এবং পাসওয়ার্ড সংরক্ষণ করছি, যা আমি একটি টার্মিনাল কমান্ড দিয়ে সেট করতে পারি। এটি আমাকে বিভিন্ন অ্যাপ্লিকেশনের জন্য একই কোড ব্যবহার করার পাশাপাশি আমার পাসওয়ার্ড না দিয়েও আপনাকে এই কোডটি দেখাতে দেয়!

সিনাত্রা র্যাকের উপরে নির্মিত কেন তা জানার জন্য এটি একটি ভাল উদাহরণ। Rack::Auth::Basic-এর মতো অনেক লাইব্রেরি উপলব্ধ রয়েছে এবং আমি সিনাত্রার সাথে সেগুলির যেকোনো একটি ব্যবহার করতে পারি। আমাকে যত কম চাকা নতুন করে তৈরি করতে হবে, ততই ভালো।

আমি আরও একটি সুরক্ষা যোগ করতে চাই: এনক্রিপশন। আমি র্যাক-এসএসএল-এনফোর্সার জেমের মাধ্যমে আমার অ্যাপ্লিকেশনটিতে SSL এনক্রিপশন যোগ করতে যাচ্ছি—ব্যাংকগুলি তাদের অনলাইন ব্যাঙ্কিং সেশনগুলি ব্যক্তিগত রাখার জন্য যে ধরণের সুরক্ষা ব্যবহার করে:

```ruby
require ‘rack-ssl-enforcer’

use Rack::SslEnforcer
```

এই লাইব্রেরি ওয়েব ব্রাউজারকে সাইটটি অ্যাক্সেস করার জন্য একটি সুরক্ষিত SSL সংযোগ ব্যবহার করতে বাধ্য করে। হেরোকু ডিফল্টরূপে হেরোকু ডোমেনে হোস্ট করা অ্যাপ্লিকেশনগুলিকে SSL ব্যবহার করার অনুমতি দেয়, তাই সেট আপ করার জন্য আর কিছুই নেই।

**"ফ্ল্যাশ" বার্তা যোগ করা**

আমি আরও একটি শেষ বৈশিষ্ট্য যোগ করতে চাই: আমি এমন ওয়েবসাইট দেখেছি যা কিছু করার পরে আপনাকে "আপনার পেজ তৈরি/সম্পাদিত/মুছে ফেলা হয়েছে" এর মতো ছোট বার্তা দেখায়। আপনি এটি কীভাবে করেন?

আমি একটু ঘেঁটে দেখি এবং সিনাত্রা-ফ্ল্যাশ নামক একটি লাইব্রেরি খুঁজে পাই যা এটি পরিচালনা করে। এই বার্তাগুলিকে "ফ্ল্যাশ" বার্তা বলা হয় এবং সেগুলি পরবর্তী পৃষ্ঠায় যাওয়ার আগে ব্যবহারকারীর ব্রাউজার কুকিতে কিছুটা টেক্সট সংরক্ষণ করে কাজ করে। যখন পরবর্তী পৃষ্ঠা লোড হয়, অ্যাপ্লিকেশনটি কুকিটি পড়ে এবং ব্যবহারকারীকে বার্তাটি প্রদর্শন করে।

আমি Gemfile এবং `application.rb`-এ লাইব্রেরিটি যোগ করেছি, উপযুক্ত রুটগুলিতে দেখাতে চেয়েছিলাম সেই বার্তাগুলি সেট করেছি, তারপর আমার ERB টেমপ্লেটগুলিতে সেই বার্তাগুলি আসলে প্রদর্শন করার জন্য কিছুটা কোড যোগ করেছি এবং আমার কাজ শেষ। আমার অ্যাপ এখন সম্পূর্ণ।

**কোড সম্পন্ন**

এখানে চূড়ান্ত কোডেক্স Readme ফাইলের শুরু:

```
Codex হল রুবিতে লেখা একটি সরল একক-ব্যবহারকারী রেফারেন্স ওয়েব অ্যাপ্লিকেশন। Codex একটি সরল Postgres ডাটাবেস থেকে পেজ রেকর্ড তৈরি, সংরক্ষণ, আপডেট এবং মুছে ফেলার জন্য Sinatra এবং DataMapper ব্যবহার করে। অ্যাপ্লিকেশনটি Heroku-তে অবিলম্বে স্থাপনের জন্য প্রস্তুত।

সমস্ত পেজের জন্য Markdown ফরম্যাটিং সক্ষম করা হয়েছে, যা সাধারণ মার্কআপ দিয়ে জটিল পেজ লেখা সহজ করে তোলে।

সমস্ত ট্র্যাফিকের জন্য HTTP প্রমাণীকরণ এবং বাধ্যতামূলক SSL আপনার তথ্য সুরক্ষিত রাখে। Bootstrap স্টাইলিং আপনার পেজগুলিকে পরিচ্ছন্ন এবং আকর্ষণীয় করে তোলে।
```

Readme হেরোকুতে অ্যাপ্লিকেশনটি কীভাবে সেট আপ করতে হয় তার বিস্তারিত নির্দেশাবলী সহ চলতে থাকে। "Readme Driven Development" একটি খুব ভালো পদ্ধতি ছিল।

মোট, Codex তৈরি করতে আমার দশ ঘন্টা সময় লেগেছে। এটি প্রোগ্রামিং শেখার জন্য আমার মোট বিনিয়োগকে বিশ ঘন্টায় নিয়ে আসে। (প্রকৃত অ্যাপ্লিকেশন লেখার চেয়ে এই অধ্যায়টি লিখতে আমার বেশি সময় লেগেছে।)

Codex তৈরি করার পরে, আমি স্থানীয় রুবি প্রোগ্রামারদের একটি মিটআপে যোগ দিয়েছিলাম এবং প্রোগ্রামটি কীভাবে কাজ করে তা ব্যাখ্যা করার জন্য স্বেচ্ছাসেবী হয়েছিলাম। প্রতিক্রিয়া খুব ইতিবাচক ছিল এবং কোডটি কতটা পরিচ্ছন্ন, সংক্ষিপ্ত এবং বোধগম্য ছিল তার জন্য আমাকে প্রশংসা করা হয়েছিল। অংশগ্রহণকারীদের একজন মন্তব্য করেছিলেন যে কোডের মান পেশাদার প্রোগ্রামারদের লেখা প্রকল্পগুলির চেয়েও ভালো ছিল যা তিনি দেখেছিলেন।

লক্ষ্য অর্জিত।

**Rage Against the Machine**

আমি একটি বিষয় স্পষ্ট করতে চাই: আমি যে প্রক্রিয়াটি বর্ণনা করেছি তা খুব সরলরৈখিক এবং সরাসরি শোনাচ্ছে। এর কারণ হল, এ পর্যন্ত, আমি যা কাজ করেছে তা বর্ণনা করেছি, যা কাজ করেনি তা নয়।

একটি দরকারী, কার্যকরী ওয়েব অ্যাপ্লিকেশন কোড করা কিছুটা অতিরিক্ত চ্যালেঞ্জ সহ একটি ধাঁধা একত্রিত করার মতো: কোন টুকরাগুলি বিদ্যমান তা আপনি জানেন না, আপনাকে কিছু টুকরা নিজেই তৈরি করতে হবে এবং যদি আপনি কোনও ভুল করেন তবে ধাঁধাটি বিস্ফোরিত হয়।

আমার প্রোগ্রামিং প্রক্রিয়াটি আসলে দেখতে কেমন ছিল তা এখানে দেওয়া হল: প্রোগ্রামের একটি অংশ কীভাবে কাজ করবে বলে আমি মনে করি তার জন্য আমি একটি ধারণা নিয়ে আসতাম। আমি কিছু কোড লিখেছিলাম, পরীক্ষা করেছিলাম এবং এটি প্রোগ্রামটি ভেঙে দিয়েছিল। আমি এটিকে সংশোধন করার চেষ্টা করতাম। কখনও কখনও আমার পরিবর্তন প্রোগ্রামটি ঠিক করত, কখনও কখনও করত না এবং কখনও কখনও এটি আরও বেশি জিনিস ভেঙে দিত। যদি আমি মারাত্মকভাবে আটকে যাই, তবে আমি Stack Overflow বা Google-এ ত্রুটি বার্তা বা লাইব্রেরি অনুসন্ধান করতাম।

আপনি যখন সবকিছু কী করে তা শিখছেন, তখন আপনার অ্যাপ্লিকেশনটি কাজ করার চেয়ে অনেক বেশি বার ভেঙে যায়। আপনি সংস্করণ নিয়ন্ত্রণের মতো জিনিসগুলির মূল্য সম্পর্কেও জানতে পারেন, যা আপনাকে আপনার কোডটিকে আগের কার্যকরী সংস্করণে ফিরিয়ে আনতে দেয়।

মনে আছে আমি কখন উল্লেখ করেছিলাম যে আমি সত্যিই বুঝতে পারিনি git কীসের জন্য? এটি এর জন্য: যদি আপনি ফাইল সম্পাদনা করছেন এবং কিছু ভেঙে যায়, তবে আপনি কী ভেঙেছে তা খুঁজে নাও পেতে পারেন। আগের কার্যকরী সংস্করণে ফিরে যাওয়া একটি আশীর্বাদ এবং স্বস্তি। যদি আপনি না পারেন তবে আপনি আতঙ্কিত হন।

যে মুহুর্তে আমি সাইডবারে যোগ করার বৈশিষ্ট্যটি কোড করা শুরু করেছিলাম, আমি অ্যাপ্লিকেশনটি ভেঙে দিয়েছিলাম। আমি কী ভুল করেছি তা খুঁজে বের করার চেষ্টা করেছিলাম, তবে আমি বুঝতে পারিনি। আমার মাথায় চুল থাকলে আমি ছিঁড়ে ফেলতাম।

ঠিক তখনই আপনি `git branch` এবং `git merge`-এর মূল্য শিখেন: আপনি আপনার প্রোগ্রামের পরীক্ষামূলক কপি তৈরি করতে পারেন, তারপর আপনার পরিবর্তনগুলি করতে পারেন। যদি আপনার কোড কাজ করে, আপনি এটিকে মূল কপিতে মার্জ করতে পারেন। যদি আপনি জিনিসগুলি নষ্ট করেন তবে আপনি আপনার আগের সমস্ত কাজ না হারিয়ে আপনার পরীক্ষামূলক শাখাটি মুছে ফেলতে পারেন।

প্রোগ্রামিং কঠিন এবং এটি নষ্ট করার লক্ষ লক্ষ উপায় রয়েছে। কম্পিউটার ক্ষমা করে না এবং খারাপভাবে গঠিত কমান্ড সহ্য করে না। একইভাবে, অপ্রত্যাশিত ফলাফল তৈরি করে এমন ছোট বিবরণ উপেক্ষা করা সহজ। আমি একটি বাগ নিয়ে ভয়ানক সময় কাটাচ্ছিলাম যা ডাটাবেসে অনেকগুলি ফাঁকা রেকর্ড সংরক্ষণ করছিল, যা "List all" পেজে দেখা যাচ্ছিল। প্রতিবার আমি পেজটি দেখতাম, তালিকায় আরও ভুতুড়ে পেজ দেখা দিত এবং আমি বুঝতে পারছিলাম না সেগুলি কোথা থেকে আসছে। শেষ পর্যন্ত এটি "list all" রুটের একটি বাগ ছিল: আমি ডাটাবেস থেকে রেকর্ডগুলি পুনরুদ্ধার করার জন্য একটি ভুল কমান্ড ব্যবহার করছিলাম।

প্রতিবার আমি কিছু ভেঙেছি, আমি কিছু শিখেছি। প্রোগ্রামিংয়ের লুকানো সুবিধাগুলির মধ্যে এটি একটি। কম্পিউটার হল সমস্ত প্রতিক্রিয়া লুপের দ্রুততম। আপনি যদি কিছু ভুল করেন তবে আপনি তা সঙ্গে সঙ্গেই জানতে পারবেন। আপনি যদি এটি সঠিকভাবে করেন তবে আপনি অবিলম্বে আপনার কাজের ফলাফল দেখতে পাবেন। আপনি যদি ঘর জুড়ে আপনার কম্পিউটার ছুঁড়ে মারার প্রবৃত্তি এড়াতে পারেন তবে তাত্ক্ষণিক প্রতিক্রিয়া প্রোগ্রামিংকে বেশ আসক্তিযুক্ত করে তুলতে পারে।

এই পরীক্ষার শুরুতে, আমি একেবারেই প্রোগ্রামিং করতে পারতাম না। এখন, আমি পারি। এটি কেবল কিছু কোডকে বশে আনতে প্রয়োজনীয় সময় ব্যয় করা এবং যখনই আমি আটকে যাই তখন ধাক্কা দেওয়া বা একটু গবেষণা করা।

আমার প্রচেষ্টার জন্য আমি কী পেলাম? প্রচুর। আমি শিখেছি প্রোগ্রামিং কী, এটি দেখতে কেমন এবং এটি কেন দরকারী। আমি স্ক্র্যাচ থেকে রুবিতে আসল কার্যকরী ওয়েব অ্যাপ্লিকেশন তৈরি করতে শিখেছি, তারপর সেগুলিকে প্রোডাকশন সার্ভারে পুশ করতে শিখেছি। আমি সিনাত্রা, হেরোকু, জেকিল, ডেটাMapper, Rake এবং অন্যান্য বহুমুখী সরঞ্জামগুলির মৌলিক বিষয়গুলি শিখেছি যা আমি দরকারী নতুন অ্যাপ্লিকেশন তৈরি করতে ব্যবহার করতে পারি। আমি ত্রুটিগুলি সমাধান করতে এবং বাগগুলি খুঁজে বের করতে শিখেছি, তারপর সেগুলি ঠিক করতে শিখেছি।

**পদ্ধতি পর্যালোচনা**

আসুন প্রোগ্রামিং শেখার জন্য আমি যে পদ্ধতিটি ব্যবহার করেছি তার মূল বিষয়গুলি পর্যালোচনা করি:

* **লক্ষ্য কর্মক্ষমতার স্তর**—আমি দুটি নির্দিষ্ট প্রোগ্রাম বেছে নিয়েছিলাম যা আমি তৈরি করতে চেয়েছিলাম, তারপর সেই প্রোগ্রামগুলি শেষ হলে কেমন দেখাবে তা সংজ্ঞায়িত করেছিলাম।
* **গবেষণা**—আমি সাধারণভাবে প্রোগ্রামিং এবং ওয়েব অ্যাপ্লিকেশনগুলি কী তা শিখতে কিছু সময় ব্যয় করেছি, তারপর এই খুব বিস্তৃত দক্ষতাগুলিকে ছোট ছোট উপ-দক্ষতায় বিভক্ত করেছি যা বোঝা এবং অনুশীলন করা সহজ।
* **সমালোচনামূলক সরঞ্জাম**—আমি নিশ্চিত করেছিলাম যে আমার কাজ করার জন্য প্রয়োজনীয় সরঞ্জাম রয়েছে (যেমন রুবি-এর সর্বশেষ সংস্করণ) এবং আমার প্রয়োজনীয় যেকোনো অতিরিক্ত সরঞ্জাম খুঁজে বের করতে এবং ব্যবহার করতে আমি সক্ষম।
* **গবেষণা**—আমি প্রোগ্রামিং তথ্যের কয়েকটি নির্ভরযোগ্য উৎস খুঁজে পেয়েছি, তবে আমি ঝাঁপিয়ে পড়ে এবং আসল প্রোগ্রামগুলি লেখার পক্ষে তৈরি টিউটোরিয়ালগুলি এড়িয়ে গেছি।
* **বিভাজন/অনুশীলন**—আমি প্রতিটি প্রকল্পকে ছোট ছোট উপ-ধাপে বিভক্ত করেছি, কোন উপ-ধাপগুলি সবচেয়ে গুরুত্বপূর্ণ বলে মনে হয়েছে তা চিহ্নিত করেছি, তারপর সবচেয়ে গুরুত্বপূর্ণ উপ-ধাপগুলিতে প্রথমে কাজ করেছি, যেমন আমার কম্পিউটারে প্রোগ্রামগুলি কীভাবে পরীক্ষা করতে হয়, সমাপ্ত অ্যাপ্লিকেশনটি প্রোডাকশনে পুশ করা ইত্যাদি।
* **অনুশীলনকারীদের সাথে কথা বলা**—আমি শুরু করতে এবং আত্মবিশ্বাস তৈরি করতে রেফারেন্স উদাহরণ এবং টিউটোরিয়াল ব্যবহার করেছি, তারপর আমি যে বৈশিষ্ট্যগুলি প্রোগ্রাম করতে চেয়েছিলাম তা বের করার জন্য বিভিন্ন পদ্ধতি পরীক্ষা করেছি।
* **দ্রুত প্রতিক্রিয়া লুপ**—আমি যখন কোনও ত্রুটি করেছি, প্রোগ্রামটি ক্র্যাশ করেছে এবং আমাকে একটি ত্রুটি বার্তা দিয়েছে। ত্রুটি পাওয়ার পরে, আমি এটি ঠিক করার জন্য বিভিন্ন উপায় নিয়ে পরীক্ষা করেছি। যদি আমি নিজে সমস্যাটি সমাধান করতে না পারতাম, তবে আমি সাহায্যের জন্য অনুসন্ধান করতাম।
* **পূর্ব-প্রতিশ্রুতি/অনুশীলন**—আমার প্রোগ্রামগুলি সম্পূর্ণ না হওয়া পর্যন্ত আমি বিল্ড/টেস্ট/ফিক্স পদ্ধতি ব্যবহার করতে থাকি।

মোট অতিবাহিত সময়: প্রায় বিশ ঘন্টা। সেই ঘন্টাগুলির মধ্যে দশ ঘন্টা গবেষণা ছিল এবং বাকি দশ ঘন্টা দুটি অ্যাপ্লিকেশন প্রোগ্রামিং করা হয়েছিল, যা এখন সমাপ্ত এবং প্রোডাকশনে রয়েছে।

**আমি এখন কোথা থেকে যাচ্ছি**

এই মৌলিক প্রকল্পগুলি সম্পন্ন করার পর থেকে আমি ওয়েব অ্যাপ্লিকেশন প্রোগ্রামিং চালিয়ে যাচ্ছি, আমার ব্যবসা চালানো সহজ করে তোলে এমন প্রোগ্রামগুলির উপর মনোযোগ দিচ্ছি।

আমি গর্বের সাথে বলতে পারি যে আমার পুরো ব্যবসা এখন আমি নিজে তৈরি করা সফ্টওয়্যারের উপর চলে। আমার অ্যাপ্লিকেশনগুলি ক্রেডিট কার্ড চার্জ করতে, সাবস্ক্রিপশন সেট আপ করতে, ইমেল পাঠাতে এবং আমার গ্রাহকদের জন্য ওয়েবসাইট অ্যাক্সেস পরিচালনা করতে সক্ষম। কোডিং শিখে, এখন আমার নিজস্ব ছোট রোবট সেনাবাহিনী রয়েছে যা আমার আদেশ পালন করার জন্য প্রোগ্রাম করা হয়েছে।

এই সমস্ত প্রোগ্রাম লিখতে কতক্ষণ সময় লেগেছে? মোট প্রায় নব্বই ঘন্টা, যার মধ্যে এই অধ্যায়ে আমি বিশটি বিস্তারিতভাবে বর্ণনা করেছি।

এখানে একটি অতিরিক্ত সুবিধা রয়েছে: যখনই আমি আমার ব্যবসার কোনও ক্ষেত্র পুনরাবৃত্তিমূলক বা হতাশাজনক মনে করি, আমি কোডের ভাষায় ভাবতে শুরু করি। এই সমস্যা সমাধান করে এমন একটি প্রোগ্রাম কীভাবে কাজ করবে? প্রায়শই, প্রক্রিয়াটিকে এমনভাবে পদ্ধতিবদ্ধ করার একটি উপায় থাকে যা আমার দৈনন্দিন জীবনকে সহজ করে তোলে।

আমি নতুন কৌশলও শিখছি, যেমন প্রোগ্রামিংকে দ্রুততর করার জন্য আমার কম্পিউটার কাস্টমাইজ করা। সময় বাঁচাতে আমি আমার টেক্সট এডিটরে কীবোর্ড শর্টকাট শিখছি এবং কোডিংকে কিছুটা সহজ করার জন্য আমি টার্মিনালকে iTerm2 এবং Z-Shell-এ আপগ্রেড করেছি।

আমি এখনও অনুশীলন করছি এবং কোনও মানদণ্ডেই আমি বিশেষজ্ঞ নই। আমাকে সবকিছু গবেষণা করতে হবে এবং সমস্যা, ত্রুটি এবং বাগগুলি সমাধান করতে আমার কিছুটা সময় লাগে। এটি প্রায়শই হতাশাজনক।

তবুও, আমি এমন প্রোগ্রাম তৈরি করছি যা সরল, নির্ভরযোগ্য উপায়ে আসল সমস্যা সমাধান করে। সেটাই আসল কথা।

আমি কম্পিউটারের সাথে লড়াই করি এবং আমি জিতি।







-
